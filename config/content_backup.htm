<h1>首頁</h1>
<p><img alt="" height="359" src="/images/15589767917_b323262fd4_c.jpg" width="574"/></p>
<p>ccc</p>
<h2>Succeeding in PC Hardware</h2>
<p id="N10654" lang="">PC Hardware is an online course, where the content will be presented in the form of both text and activities.</p>
<p id="N10657" lang="">While you will have more flexibility than in a traditional course, you will also have more responsibility for your own learning. You will need to:</p>
<ul lang="">
<li lang="">Plan how to work through each unit.</li>
<li lang="">Determine how to use the various features of the course to help you learn.</li>
<li lang="">Decide when you need to seek additional support.</li>
</ul>
<p id="N10654" lang=""></p>
<h1>週進度</h1>
<table>
<tbody>
<tr style="height: 15px;">
<td style="height: 15px;">W1:</td>
<td style="height: 15px;">建立倉儲</td>
<td style="height: 15px;">100%</td>
</tr>
<tr style="height: 15px;">
<td style="height: 15px;"><span>W2:</span></td>
<td style="height: 15px;"><span>建立網頁</span></td>
<td style="height: 15px;"><span>100%</span></td>
</tr>
<tr style="height: 15px;">
<td style="height: 15px;"><span>W3:</span></td>
<td style="height: 15px;"><span>拍攝網站教學影片</span></td>
<td style="height: 15px;"><span>100%</span></td>
</tr>
<tr style="height: 15px;">
<td style="height: 15px;"><span>W4:</span></td>
<td style="height: 15px;"><span>PC Hardware帳號建立</span></td>
<td style="height: 15px;">100%</td>
</tr>
<tr style="height: 107px;">
<td style="height: 107px;"><span>W5:</span></td>
<td style="height: 107px;">
<p>PC HardwareUNIT 1，UNIT 2，PCH 1，</p>
<p><span>完成英翻中文放到網頁上</span></p>
</td>
<td style="height: 107px;">
<p><span>UNIT1:100%</span></p>
<p><span>UNIT2:100%</span></p>
<p>PCH1:70%</p>
<p><span></span></p>
</td>
</tr>
<tr style="height: 63px;">
<td style="height: 63px;">W6:</td>
<td style="height: 63px;">
<p><span>PCH 1英翻中</span></p>
<p><span>網路配置放到網頁上</span></p>
</td>
<td style="height: 63px;">
<p><span>PCH1:90%</span></p>
<p><span>網路配置:20%</span></p>
</td>
</tr>
<tr style="height: 111px;">
<td style="height: 111px;">W7:</td>
<td style="height: 111px;">
<p><span>PCH 1英翻中</span></p>
<p>W7</p>
<p>https://www.kaggle.com/liaochienyu/cp2020w7</p>
<p>BUG cmsinde錯誤</p>
</td>
<td style="height: 111px;">
<p><span>PCH1:100%</span></p>
<p><span>W7:25%</span></p>
<p>cmsimde:100%</p>
</td>
</tr>
<tr style="height: 107px;">
<td style="height: 107px;">w8:</td>
<td style="height: 107px;">
<p><span>W7</span></p>
<p><span>https://www.kaggle.com/liaochienyu/cp2020w7</span></p>
<p><span>w8</span></p>
<p><span>https://www.kaggle.com/liaochienyu/cp2020w8</span></p>
</td>
<td style="height: 107px;">
<p><span>w7:50%</span></p>
<p><span>網路環境介紹100%</span></p>
</td>
</tr>
<tr style="height: 37px;">
<td style="height: 37px;">w9:</td>
<td style="height: 37px;">
<p><span>期中考週</span></p>
</td>
<td style="height: 37px;">
<p><span>期中考週</span></p>
</td>
</tr>
<tr style="height: 63px;">
<td style="height: 63px;">w10:</td>
<td style="height: 63px;">
<p>程式練習(原w7標題)</p>
<p><span>程式練習(w10)</span></p>
</td>
<td style="height: 63px;">
<p>100%</p>
<p><span>100%</span></p>
</td>
</tr>
<tr style="height: 22px;">
<td style="height: 22px;"><span>w11</span></td>
<td style="height: 22px;">開始homework 3分組，組裡的cmsimde網站</td>
<td style="height: 22px;">100%</td>
</tr>
<tr style="height: 21px;">
<td style="height: 21px;"><span>w12</span></td>
<td style="height: 21px;">增加網站內容</td>
<td style="height: 21px;">80%</td>
</tr>
<tr style="height: 23.4688px;">
<td style="height: 23.4688px;"><span>w13</span></td>
<td style="height: 23.4688px;">繼續進行hw3內容</td>
<td style="height: 23.4688px;">80%</td>
</tr>
<tr style="height: 23px;">
<td style="height: 23px;"><span>w14</span></td>
<td style="height: 23px;"></td>
<td style="height: 23px;"></td>
</tr>
<tr style="height: 59px;">
<td style="height: 59px;">w15</td>
<td style="height: 59px;">
<p><span></span></p>
<p></p>
</td>
<td style="height: 59px;">
<p><span></span></p>
</td>
</tr>
</tbody>
</table>
<p></p><h2>0</h2>
<p><strong></strong></p>
<p id="N10654" lang=""></p>
<h1>組員名單bg4</h1>
<p><strong>網站:</strong></p>
<p><strong>https://40923252.github.io/cp2020bg4/content/index.html</strong></p>
<p><strong>組長:</strong></p>
<p><strong><span>40923252 魏柏旻</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923252.github.io/cp2020/content/index.html">https://40923252.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><a href="https://github.com/40923252/cp2020">https://github.com/40923252/cp2020</a></span></p>
<p><strong>組員:</strong></p>
<p><strong><span>40723217 林立翔</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40723217.github.io/cp2020/content/index.html">https://40723217.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40723217/cp2020">https://github.com/40723217/cp2020</a></span></span></p>
<p><strong><span>40728238 廖建佑</span></strong><br/><strong>CMSiMDE：</strong><span><a href="https://40728238.github.io/cp2020/content/index.html">https://40728238.github.io/cp2020/content/index.html</a></span><br/><strong>Github：</strong><span><a href="https://github.com/40728238/cp2020">https://github.com/40728238/cp2020</a></span></p>
<p><strong><span>40923206 黃思喬</span></strong><br/><strong>CMSiMDE：</strong><span><a href="https://40923206-1.github.io/cp2020/content/index.html">https://40923206-1.github.io/cp2020/content/index.html</a></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923206-1/cp2020">https://github.com/40923206-1/cp2020</a></span></span></p>
<p><strong><span>40923216 陳彥廷</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923216.github.io/cp2020/content/index.html">https://40923216.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923216/cp2020">https://github.com/40923216/cp2020</a></span></span></p>
<p><strong><span>40923220 陳胡文</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923220.github.io/cp2020/content/index.html">https://40923220.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><a href="https://github.com/40923220/cp2020">https://github.com/40923220/cp2020</a></span></p>
<p><strong><span>40923227 黃宇陽</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923227.github.io/cp2020/content/index.html">https://40923227.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923227/cp2020">https://github.com/40923227/cp2020</a></span></span></p>
<p><strong><span>40923233 楊建霖</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923233.github.io/cp2020/content/index.html">https://40923233.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923233/cp2020">https://github.com/40923233/cp2020</a></span></span></p>
<p><strong><span>40923237 詹明憲</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923237.github.io/cp2020/content/index.html">https://40923237.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923237/cp2020">https://github.com/40923237/cp2020</a></span></span></p>
<p><strong><span>40923243 鄭丞崴</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923243.github.io/cp2020/content/index.html">https://40923243.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923243/cp2020">https://github.com/40923243/cp2020</a></span></span></p>
<p><strong><span>40923253 蘇政嘉</span></strong><br/><strong>CMSiMDE：</strong><span><span><a href="https://40923253.github.io/cp2020/content/index.html">https://40923253.github.io/cp2020/content/index.html</a></span></span><br/><strong>Github：</strong><span><span><a href="https://github.com/40923253/cp2020">https://github.com/40923253/cp2020</a></span></span></p>
<p></p>
<h1>HomeWork 1</h1>
<h2>網路設定</h2>
<p>ipv4:第四版網路協定</p>
<p>ipv6:第六版網路協定</p>
<p>proxy設定:[2001:288:6004:17::69]:3128  /有69，53，42三種選項  </p>
<p>cmd指令</p>
<p>ipconfig:可以查看網路狀況與ip位置。</p>
<p>ping 2001:288:6004:17::254:連到機械設計的通道</p>
<p>ping -t 2001:288:6004:17::254:不斷地送封包給機械設計系(可以檢查網路線)</p>
<p></p>
<h2>個人分配P.13~24</h2>
<p><strong>p.13</strong></p>
<p><strong>External Components of the Desktop System Unit</strong></p>
<p>桌上主機系統的外部組件</p>
<p>The lab activity below is designed to help you locate and understand the purpose of the various bays and ports on a desktop PC system unit. To identify components, move your mouse pointer over the name of the component or the image. Then be sure to click on each component to see a detailed view. In the detailed view, you will be able to examine the cables of various peripherals. You also will be able to see the most common bays and the way peripherals fit into them. </p>
<p>After you've had the opportunity to use the simulator carefully, answer the question below.</p>
<p>下面的實驗旨在幫助您查找和了解桌式PC系統單元上各種托架和端口的用途。 要識別組件，請將鼠標指針移到組件或圖像的名稱上。然後，單擊每個組件以查看詳細視圖。在詳細視圖中，您將能夠檢查各種外圍設備的電纜。您還將能夠看到最常見的托架以及外圍設備裝入它們的方式。</p>
<p><strong>在有機會仔細使用模擬器之後，請回答以下問題。</strong></p>
<p><strong><img caption="false" height="323" src="/images/Screenshot_20201018-003715_1.jpg" width="600"/></strong></p>
<p><img caption="false" height="600" src="/images/Screenshot_20201016-022800_1.jpg" width="426"/><img caption="false" height="600" src="/images/Screenshot_20201016-022828_1.jpg" width="426"/><img alt="" height="600" src="/images/Screenshot_20201016-023003_1.jpg" width="426"/></p>
<p></p>
<p>p.14</p>
<p>Connections Between Common Peripherals and Standard Ports</p>
<p>通用外設與標準端口之間的連接</p>
<p>The peripherals connect to the computer via standard ports. Ports allow for information to flow into or out of the computer as part of the input and output subsystems. External devices, such as keyboards, mice, printers, scanners, storage devices, monitors, and others can connect to the computer through various types of cables, which connect to specific ports. On most modern systems, this has been reduced down to a common, standard interface, the universal serial bus port (USB port). Older systems have various ports for various functions, which are now referred to as legacy ports, such as PS/2, serial, and parallel ports. They were difficult to configure and required hardware resources to be dedicated to them, such as interrupt requests, direct memory access, and specific I/O (input/output) port addresses. In USB, this is all handled by the operating system automatically. This makes hardware conflicts rare in current systems. Many customers will still have computers with legacy ports. So, it is important to understand multiple ports and connections.</p>
<p>The photo below offers a close-up view of a motherboard’s port cluster.</p>
<p>外圍設備通過標準端口連接到計算機。端口允許信息作為輸入和輸出子系統的一部分流入或流出電腦。外部設備（例如鍵盤，鼠標，印刷機，掃描儀，存儲設備，監視器和其他設備）可以通過連接到特定端口的各種類型的電纜連接到電腦。在大多數現代系統上，這已簡化為通用的標準接口，即通用串行總線端口（USB端口）。較舊的系統具有用於各種功能的各種端口，這些端口現在稱為傳統端口，例如PS / 2，串行和並行端口。它們很難配置，並且需要專用於它們的硬件資源，例如中斷請求，直接內存訪問和特定的I / O（輸入/輸出）端口地址。在USB中，這全部由操作系統自動處理。這使得在當前系統中很少發生硬件衝突。許多客戶仍將擁有帶有舊端口的電腦。因此，了解多個端口和連接很重要。</p>
<p><img caption="false" height="463" src="/images/image20.png" width="650"/></p>
<table style="width: 720px; border-color: #000000; background-color: #f5f5f5;">
<tbody>
<tr>
<td style="width: 43.2px;">
<p>PORT</p>
<p>部位</p>
</td>
<td style="width: 55.8px;">
<p>NAME</p>
<p>名稱</p>
</td>
<td style="width: 592px;">
<p>FUNCTION</p>
<p>作用</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>A</p>
</td>
<td style="width: 55.8px;">
<p>PS/2</p>
</td>
<td style="width: 592px;">
<p>Used to connect keyboards and mice.</p>
<p>用於連接鍵盤和鼠標。</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>B</p>
</td>
<td style="width: 55.8px;">
<p>USB</p>
</td>
<td style="width: 592px;">
<p>Used to connect external devices with a <strong>universal serial bus</strong> (USB) connector, such as mice, keyboards, printers, and storage devices.</p>
<p>用於通過通用串行總線（USB）連接器連接外部設備，例如鼠標，鍵盤，打印機和存儲設備。</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>C</p>
</td>
<td style="width: 55.8px;">
<p>S/PDIF Optical</p>
</td>
<td style="width: 592px;">
<p>Used to connect digital high-fidelity audio systems.</p>
<p>用於連接數位高保真音頻系統。</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>D</p>
</td>
<td style="width: 55.8px;">
<p>HDMI</p>
</td>
<td style="width: 592px;">
<p>Used to connect a <strong>high-definition multimedia interface </strong>(HDMI).</p>
<p>用於連接高清多媒體接口</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>E</p>
</td>
<td style="width: 55.8px;">
<p>VGA</p>
</td>
<td style="width: 592px;">
<p>Used to connect a <strong>video graphics array </strong>(VGA) display device.</p>
<p>用於連接視頻圖形陣列（VGA）顯示設備</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>F</p>
</td>
<td style="width: 55.8px;">
<p>DVI</p>
</td>
<td style="width: 592px;">
<p>Used to connect a <strong>digital video interface </strong>(DVI) display device.</p>
<p>用於連接數位視頻接口（DVI）顯示設備。</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>G</p>
</td>
<td style="width: 55.8px;">
<p>USB</p>
</td>
<td style="width: 592px;">
<p>Used to connect external devices with a <strong>universal serial bus</strong> (USB) connector, such as mice, keyboards, printers, and storage devices.</p>
<p>用於通過通用串行總線（USB）連接器連接外部設備，例如鼠標，鍵盤，打印機和存儲設備。</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>H</p>
</td>
<td style="width: 55.8px;">
<p>IEEE 1394</p>
</td>
<td style="width: 592px;">
<p>Used to connect external FireWire devices, such as hard drives and cameras.</p>
<p>用於連接外部FireWire設備，例如硬盤驅動器和相機</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>I</p>
</td>
<td style="width: 55.8px;">
<p>RJ-45</p>
</td>
<td style="width: 592px;">
<p>Used to connect to an Ethernet network.</p>
<p>用於連接到以太網路</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>J</p>
</td>
<td style="width: 55.8px;">
<p>USB</p>
</td>
<td style="width: 592px;">
<p>Used to connect external devices with a <strong>universal serial bus</strong> (USB) connector, such as mice, keyboards, printers, and storage devices.</p>
<p>用於通過通用串行總線（USB）連接器連接外部設備，例如鼠標，鍵盤，打印機和存儲設備。</p>
</td>
</tr>
<tr>
<td style="width: 43.2px;">
<p>K</p>
</td>
<td style="width: 55.8px;">
<p>Audio</p>
</td>
<td style="width: 592px;">
<p>Used to connect to a speaker system.</p>
<p>用於連接揚聲器系統。</p>
</td>
</tr>
</tbody>
</table>
<p><img caption="false" height="517" src="/images/image21.png" width="650"/></p>
<table style="border-color: #000000; background-color: #f7f5f5;">
<tbody>
<tr>
<td>
<p>CONNECTOR</p>
</td>
<td>
<p>NAME</p>
</td>
<td>
<p>FUNCTION</p>
</td>
</tr>
<tr>
<td>
<p>A</p>
</td>
<td>
<p>DB-9 serial</p>
</td>
<td>
<p>Used for serial devices such as a mouse or external modem.</p>
<p>用於串行設備，例如鼠標或外部調製解調器。</p>
</td>
</tr>
<tr>
<td>
<p>B</p>
</td>
<td>
<p>DB-25 parallel</p>
</td>
<td>
<p>Used to connect printers.</p>
<p>用於連接印刷機。</p>
</td>
</tr>
<tr>
<td>
<p>C</p>
</td>
<td>
<p>DB-15 <strong>(two rows of pin receptacles)</strong></p>
</td>
<td>
<p>Used to connect joysticks or <strong>musical instrument digital interface </strong>(MIDI) devices.</p>
<p>用於連接操縱桿或樂器數字接口（MIDI）設備。</p>
</td>
</tr>
<tr>
<td>
<p>D</p>
</td>
<td>
<p>High-density DB-15 <strong>(three rows of pins)</strong></p>
</td>
<td>
<p>Used to connect a <strong>video graphics array</strong> (VGA) and <strong>super VGA</strong> (SVGA) display device.</p>
<p>用於連接視頻圖形陣列（VGA）和超級VGA（SVGA）顯示設備。</p>
</td>
</tr>
<tr>
<td>
<p>E</p>
</td>
<td>
<p>DVI video</p>
</td>
<td>
<p>Used to connect a <strong>digital video interface (DVI)</strong> display monitor.</p>
<p>用於連接數字視頻接口（DVI）顯示監視器。</p>
</td>
</tr>
<tr>
<td>
<p>F</p>
</td>
<td>
<p>6-pin mini-DIN</p>
</td>
<td>
<p>Used for PS/2 keyboards and mice. By convention, purple connectors are used for keyboards and green connectors are used for mice.</p>
<p>用於PS / 2鍵盤和鼠標。 按照慣例，紫色連接器用於鍵盤，綠色連接器用於鼠標。</p>
</td>
</tr>
<tr>
<td>
<p>G</p>
</td>
<td>
<p>RJ-11 (four wires inside plug interface)</p>
</td>
<td>
<p>Used for internal modem or telephone.</p>
<p>用於內部調製解調器或電話。</p>
</td>
</tr>
<tr>
<td>
<p>H</p>
</td>
<td>
<p>RJ-45 <strong>(eight wires inside jack interface)</strong></p>
</td>
<td>
<p>Used to connect to an Ethernet network.</p>
<p>用於連接到以太網路。</p>
</td>
</tr>
<tr>
<td>
<p>I</p>
</td>
<td>
<p>USB type A</p>
</td>
<td>
<p>Used for external <strong>universal serial bus</strong> (USB) devices such as printers and storage devices.</p>
<p>用於外部通用串行總線（USB）設備，例如打印機和存儲設備。</p>
</td>
</tr>
<tr>
<td>
<p>J</p>
</td>
<td>
<p>HDMI</p>
</td>
<td>
<p>Used to connect a <strong>high definition multimedia interface (HDMI)</strong> display monitor.</p>
<p>用於連接高清多媒體接口（HDMI）顯示監視器。</p>
</td>
</tr>
<tr>
<td>
<p>K</p>
</td>
<td>
<p>Mini Stereo</p>
</td>
<td>
<p>Also known as "1/8 inch" or "3.5 mm" connectors, these are used to connect audio devices such as headphones and speakers.</p>
<p>也稱為“ 1/8英寸”或“ 3.5毫米”連接器，這些連接器用於連接音頻設備，例如耳機和揚聲器。</p>
</td>
</tr>
</tbody>
</table>
<p></p>
<p>p.15</p>
<p>USB AND PS/2</p>
<p>USB和PS / 2</p>
<p>USB</p>
<p>The universal serial bus (USB) has replaced many of the external input and output ports on modern computers. In fact, USB can connect virtually any device to a computer, in modern devices.</p>
<p>USB</p>
<p>通用串行總線（USB）取代了現代計算機上的許多外部輸入和輸出端口。 實際上，在現代設備中，USB幾乎可以將任何設備連接到計算機。</p>
<p>Things such as mice and keyboards, which used to use PS/2 or serial ports, now use USB. Things like printers and scanners, which once used parallel or SCSI ports, now use USB as well. Small computer system interface (SCSI) is a set of parallel interface standards developed by the American National Standards Institute (ANSI) for attaching printers, disk drives, scanners and other peripherals to computers. SCSI (pronounced "skuzzy") is supported by all major operating systems. USB began with version 1.1, which provided two speeds of operations: low-speed (1.5 Mbps for input devices such as mice/keyboards) and full-speed (12 Mbps for other devices, such as webcams, digital cameras, scanners, and printers). USB 2.0 further increased speed to what is known as high-speed or hi-speed (480 Mbps), allowing for USB to provide faster access to external storage devices such as hard drives, helping to replace SCSI and FireWire ports. USB 3.0, the current version, is known as superspeed, because it provides up to 5 Gbps of bandwidth for very fast access to external devices and can be identified by the blue color. Newer versions of USB are backward compatible with older versions, but you should not connect different versions of USB on the same port, as this slows the port down to the lowest version. For example, if you plug in a four-port USB hub to a USB 3.0 port, but then connect a USB 1.1 mouse to the hub, the entire four-port hub will now run at a maximum speed of 12 Mbps (USB 1.1 speeds). Each USB port can be daisy-chained to provide up to 127 devices per port, using USB hubs.</p>
<p>鼠標和鍵盤等以前使用PS / 2或串行端口的設備現在使用USB。曾經使用並行或SCSI端口的打印機和掃描儀之類的東西現在也使用USB。小型計算機系統接口（SCSI）是由美國國家標準協會（ANSI）開發的一組並行接口標準，用於將印刷機，磁盤驅動器，掃描儀和其他外圍設備連接到電腦。所有主要操作系統都支持SCSI（讀作“ skuzzy”）。 USB從版本1.1開始，提供兩種運行速度：低速（對於鼠標/鍵盤等輸入設備為1.5 Mbps）和全速（對於網絡攝像頭，數碼相機，掃描儀和打印機等其他設備為12 Mbps） ）。 USB 2.0將速度進一步提高到所謂的高速或高速（480 Mbps），從而使USB可以更快地訪問外部存儲設備（例如硬盤驅動器），從而幫助替換SCSI和FireWire端口。當前版本的USB 3.0被稱為超高速，因為它提供高達5 Gbps的帶寬，可以非常快速地訪問外部設備，並且可以通過藍色識別。較新版本的USB向後兼容較舊版本的USB，但是您不應在同一端口上連接不同版本的USB，因為這會將端口速度降低到最低版本。例如，如果將四端口USB集線器插入USB 3.0端口，然後將USB 1.1鼠標連接到集線器，則整個四端口集線器現在將以12 Mbps的最大速度運行（USB 1.1速度）。每個USB端口都可以使用USB集線器進行菊花鏈連接，以每個端口提供多達127個設備。</p>
<p><img caption="false" height="413" src="/images/image32.png" width="550"/></p>
<p>USB cables should be kept under three meters (approximately nine feet) in length for USB 1.1 and 3.0. For the USB 2.0 variant, you can use cables up to five meters (approximately 15 feet) without issues. If you use cables longer than the recommended length, you may get errors in your input/output over USB, so it is best to keep the USB cables short. If you need a longer cable run, you must use a hub as a repeater to help boost the power signal over the USB cable. There are two types of hubs: self-powered and bus-powered. Self-powered hubs have their own power adapter and connect to the wall outlet to provide power to the hub. Bus-powered are instead powered solely from the source USB port that they are connected to on the computer. This provides minimal amperage for the devices connected to the USB hub that can cause issues when connecting multiple hubs to each other. For connection of multiple hubs, it is best practice to use self-powered hubs. Each USB port can support up to 127 different devices in the chain, with the root hub for the computer having two ports directly connected to the motherboard. If you need more USB ports, you can do this by adding hubs (self-powered or bus-powered), using motherboard USB header cables, or adding expansion cards that contain more USB ports.</p>
<p>對於USB 1.1和3.0，USB電纜的長度應保持在三米（約9英尺）以下。對於USB 2.0版本，您可以使用最長5米（約15英尺）的電纜而不會出現問題。如果使用的電纜長度超過建議的長度，則通過USB的輸入/輸出可能會出現錯誤，因此最好使USB電纜的長度短。如果需要較長的電纜，則必須使用集線器作為中繼器，以幫助增強USB電纜上的電源信號。集線器有兩種類型：自供電和總線供電。自供電的集線器具有自己的電源適配器，並連接至壁裝電源插座，以為集線器供電。總線供電僅由它們在計算機上連接的源USB端口供電。這為連接到USB集線器的設備提供了最小的電流強度，當將多個集線器相互連接時會引起問題。對於連接多個集線器，最佳做法是使用自供電集線器。每個USB端口可在鏈中最多支持127個不同的設備，計算機的根集線器具有直接連接到主板的兩個端口。如果需要更多USB端口，可以通過添加集線器（自供電或總線供電），使用主板USB接頭連接器電纜或添加包含更多USB端口的擴展卡來實現。<br/><a href="https://github.com/mdecourse/cmsimde"></a></p>
<p><img alt="" height="450" src="/images/image33.png" width="600"/></p>
<p>PS/2</p>
<p>PS/2 ports, also known as mini-DIN ports, were commonly used for keyboards and mice until the past decade. Recently, these ports have been replaced by USB in most machines. These ports, though, are color-coded for the device which they are intended to be used with. The keyboard port is colored purple, and the mouse port is colored green. Even though these ports look identical, they are not interchangeable. If you plug a mouse into the keyboard port, it simply won’t work. Additionally, unlike USB, these ports are not hot-swappable. Instead, you must restart the machine after plugging the device in for the computer to recognize the new mouse or keyboard.</p>
<p>PS / 2</p>
<p>PS / 2端口，也稱為mini-DIN端口，在過去十年中一直廣泛用於鍵盤和鼠標。最近，在大多數機器中，這些端口已被USB取代。但是，這些端口已針對要使用的設備進行了顏色編碼。 鍵盤端口為紫色，鼠標端口為綠色。 即使這些端口看起來相同，也不能互換。如果將鼠標插入鍵盤端口，則根本無法使用。 此外，與USB不同，這些端口不可熱插拔。 而是必須在插入設備後重新啟動機器，計算機才能識別新的鼠標或鍵盤。</p>
<p><img alt="Photo depicting two PS/2 ports.      One port is periwinkle blue. The other port is teal green." height="241" src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH01/webcontent/PCH01/image34.jpeg" width="599"/></p>
<p>p.16</p>
<p>SCSI and FireWire</p>
<p>SCSI和FireWire</p>
<p>FireWire</p>
<p>FireWire was originally developed and made popular by Apple as a challenger to USB and a replacement for SCSI. FireWire is a high-speed, bidirectional, serial transmission port used to connect PCs to each other, or devices to PCs. It was introduced during the days of USB 1.1 as a faster alternative, since USB 1.1 had a maximum speed of 12 Mbps and FireWire has a maximum speed of 400 Mbps under IEEE 1394a (FireWire 400) and 800 Mbps under IEEE 1394b (Firewire 800). Common uses for FireWire were to connect to external storage devices and digital media devices, such as video cameras. Most FireWire devices have two FireWire ports to allow for daisy-chaining of the devices, which supports up to 16 devices per FireWire port without any degradation. FireWire remains popular with Mac OS X, but has lost much of its popularity with the introduction of USB 3.0, since the speed is much quicker with USB 3.0.</p>
<p>FireWire最初是由Apple開發並流行為USB的挑戰者和SCSI的替代品。 FireWire是一個高速雙向串行傳輸端口，用於將PC彼此連接，或將設備連接至PC。 由於USB 1.1的最高速度為12 Mbps，而FireWire在IEEE 1394a（FireWire 400）下為400 Mbps，在IEEE 1394b（Firewire 800）下為800 Mbps，因此它是USB 1.1的最快替代產品。 。 FireWire的常見用途是連接到外部存儲設備和數字媒體設備，例如攝像機。 大多數FireWire設備都有兩個FireWire端口，以實現設備的菊花鏈連接，每個FireWire端口最多可支持16個設備，而不會降低性能。 FireWire在Mac OS X上仍然很流行，但是由於USB 3.0的速度要快得多，因此在引入USB 3.0時已經失去了很多流行性。</p>
<p><img caption="false" height="553" src="/images/image36.png" width="550"/></p>
<p>SCSI</p>
<p>SCSI stands for small computer systems interface, and is a legacy type of connector. It is used to connect hard disk drives, tape drives, ZIP drives, JAZ drives, scanners, optical drives (CD/DVD), and printers to a computer both internally and externally. SCSI is found mainly in servers for hard disk drives and tape drives, but was sometimes found in older workstations in the 1990s. SCSI supports daisy-chaining and was the precursor to FireWire. SCSI can be narrow (supporting up to seven devices on a single port) or wide (supporting up to 15 devices on a single port). SCSI also requires that a unique ID be assigned to each device in the chain, so the computer knows which device is which. This is accomplished using either a DIP switch or jumper that assigns a unique ID of 0-15 (for wide), or 0-7 (for narrow). Finally, each chain must have a termination plug to signify the end of the SCSI chain. SCSI chains can contain many devices of mixed speeds, but this causes the whole “chain” to default to the slowest device. Speed for SCSI ranges from 10 Mbps to 320 Mbps. Since the advent of FireWire, SCSI has lost popularity as an external port for storage devices. Internally, SCSI has been replaced by the SATA[KK1] connector, which we will discuss in the section on storage later in the course.</p>
<p>SCSI代表小型電腦系統接口，並且是舊版連接器。它用於將硬盤驅動器，磁帶驅動器，ZIP驅動器，JAZ驅動器，掃描儀，光盤驅動器（CD / DVD）和印刷機內部和外部連接到計算機。 SCSI主要在用於硬盤驅動器和磁帶驅動器的服務器中找到，但有時在1990年代在較舊的工作站中也可以找到。 SCSI支持菊花鏈，並且是FireWire的前身。 SCSI可以很窄（在單個端口上最多支持七個設備）或很寬（在單個端口上最多支持15個設備）。 SCSI還要求將唯一的ID分配給鏈中的每個設備，以便電腦知道哪個設備是哪個設備。這可以通過使用DIP開關或跳線來完成，該開關將唯一ID分配為0-15（對於寬）或0-7（對於窄）。最後，每個鏈必須有一個端接插頭以表示SCSI鏈的末端。 SCSI鏈可能包含許多混合速度的設備，但這會導致整個“鏈”默認為最慢的設備。 SCSI的速度範圍從10 Mbps到320 Mbps。自FireWire出現以來，SCSI作為存儲設備的外部端口已不再流行。在內部，SCSI已由SATA [KK1]連接器取代，我們將在本課程稍後的存儲部分中討論該連接器。</p>
<p><img alt="" height="498" src="/images/image37.png" width="550"/></p>
<p></p>
<p>p.17</p>
<p>Serial and Parallel Ports</p>
<p>串行和並行端口</p>
<p>Serial ports</p>
<p>Serial ports, also known as COM or RS-232 ports, were used heavily in the 1980s and 1990s for serial communication as input/output ports. They were often used for external modems, mice, trackballs, touchpads, plotters, label printers, dot-matrix printers, PDA (Palm Pilot) docking stations, digital cameras, and PC-to-PC connections. USB has replaced serial ports for all of these uses in modern computers, but some people still have a need for a serial port. If your computer doesn’t have a serial port (which is very common in modern machines), you can add one using an expansion card or a USB to serial adapter. Serial ports come in two varieties: DB-25 (containing 25 pins) and DB-9 (containing nine pins). The DB-9 variety is the most common in use. Serial ports are generally slow, since they send data one bit at a time over the wire. There is no standard serial cable pinout; instead, they are created for the application they are used for, such as a null-modem cable to connect two computers directly, or a modem cable to connect the computer to an external modem. The most common variety of serial cable in use today is the CISCO rollover cable, which has a nine-pin serial port on one end and an RJ-45 connector (like a network cable) on the other end. This cable is used to connect a computer to a CISCO router or switch for configuration tasks.</p>
<p>串行端口，也稱為COM或RS-232端口，在1980年代和1990年代被大量用於串行通信，作為輸入/輸出端口。它們通常用於外部調製解調器，鼠標，軌跡球，觸摸板，繪圖儀，標籤印刷機，點矩陣印刷機，PDA（Palm Pilot）擴展塢，數碼相機以及PC到PC的連接。 USB已取代了現代計算機中所有這些用途的串行端口，但是有些人仍然需要串行端口。如果您的電腦沒有串行端口（這在現代計算機中很常見），則可以使用擴展卡或USB到串行適配器添加一個。串行端口有兩種：DB-25（包含25個引腳）和DB-9（包含9個引腳）。 DB-9品種是最常用的品種。串行端口通常很慢，因為它們一次通過有線發送數據一位。沒有標準的串行電纜引出線。相反，它們是針對用於它們的應用程序創建的，例如直接連接兩台電腦的零調製解調器電纜，或用於將電腦連接到外部調製解調器的調製解調器電纜。當今使用的最常見的串行電纜是CISCO翻轉電纜，其一端有一個9針串行端口，而另一端有一個RJ-45連接器（如網絡電纜）。該電纜用於將電腦連接到CISCO路由器或交換機以執行配置任務。</p>
<p><img alt="" height="298" src="/images/image38.png" width="550"/></p>
<p><img alt="" height="333" src="/images/image39.png" width="550"/></p>
<p>Parallel ports</p>
<p>Parallel ports, also known as LPT (line printer terminal) ports, were used heavily in the 1980s and 1990s for parallel communication as input/output ports. They were often used for printers and scanners. USB has replaced parallel ports for all of these uses in modern computers, and few people will still have a need for a parallel port in contemporary computing. If your computer doesn’t have a parallel port (which is very common in modern machines), you could add one using an expansion card or a USB to parallel adapter. Parallel ports come in a standard DB-25 (containing 25 pins) cable. Other varieties of cables exist, including a DB-25 to Centronics 36-pin cable (common with printers), DB-25 to DB-25 cable (common with switchboxes), and DB-25 to DB-25 with the transmit/receive pins reversed (common for computer to computer connections for data transfer). Parallel ports are generally faster than serial ports, since they send data in parallel with eight bits at a time going over the wire. Parallel ports can be configured as output only or bidirectional ports. The ports are also configured as EPP (enhanced parallel port), ECP (enhanced capabilities port), and EPP/ECP. Under EPP, the port uses interrupt request (IRQ) and I/O addresses for fastest speeds. In ECP, the port can support daisy-chaining of devices and uses IRQ, I/O address, and DMA channels, and is considered resource hungry. EPP/ECP combines both modes into a single configuration, allowing for maximum compatibility. Parallel ports transmit data at up to two Mbps and receive data at 500 Kbps, which is very slow by today’s standards.</p>
<p>並行端口，也稱為LPT（行式印刷機終端）端口，在1980年代和1990年代大量用於並行通信，作為輸入/輸出端口。它們通常用於印刷機和掃描儀。 USB已經取代了並行端口，可用於現代電腦中的所有這些用途，而當代電腦中仍然很少有人需要並行端口。如果您的電腦沒有並行端口（這在現代電腦中很常見），則可以使用擴展卡或USB到並行適配器添加一個。並行端口採用標準的DB-25（包含25針）電纜。還存在其他種類的電纜，包括DB-25至Centronics 36針電纜（與印刷機共用），DB-25至DB-25電纜（與配電箱共用）以及具有發送/接收功能的DB-25至DB-25引腳接反（電腦到電腦的連接通常用於數據傳輸）。並行端口通常比串行端口快，因為並行端口一次通過8位並行發送數據。並行端口可以配置為僅輸出端口或雙向端口。這些端口還配置為EPP（增強型並行端口），ECP（增強功能端口）和EPP / ECP。在EPP下，端口使用中斷請求（IRQ）和I / O地址以獲得最快的速度。在ECP中，端口可以支持設備的菊花鏈連接，並使用IRQ，I / O地址和DMA通道，並且被認為是資源匱乏。 EPP / ECP將兩種模式組合為一個配置，以實現最大的兼容性。並行端口以高達2 Mbps的速率發送數據，並以500 Kbps的速率接收數據，按照當今的標準，這是非常慢的。</p>
<p><img alt="" height="412" src="/images/image40.png" width="550"/></p>
<p><img alt="" height="418" src="/images/image41.png" width="550"/></p>
<p></p>
<p>p.19</p>
<p>Introduction</p>
<p>介紹</p>
<p>This lesson covers the basic procedures and safety precautions with which technicians must be competent and comfortable before working on various PC hardware. First we will discuss the hazards of computer systems and tools, including electricity, electrostatic discharge (ESD), chemicals, and other dangers that can hurt you when you are working on the various forms of computer hardware. We will also cover the safety measures and procedures that you must employ to minimize risk, such as using ESD straps, ESD mats, self-grounding systems, and equipment grounding. We will then discuss personal safety, including removal of jewelry to protect yourself and computers, proper lifting techniques and weight limitations, and removal of electrical power. Finally, we will cover electrical fire safety, cathode ray tube (CRT) safety and disposal, cable management, and local government regulation compliance.</p>
<p>本課程涵蓋了基本程序和安全預防措施，技術人員在使用各種PC硬件之前必須具備一定的能力和舒適度。 首先，我們將討論電腦系統和工具的危害，包括電流，靜電釋放（ESD），化學物質以及在使用各種形式的電腦硬件時可能傷害您的其他危害。 我們還將介紹必須使用以最小化風險的安全措施和程序，例如使用ESD皮帶，ESD墊，自接地系統和設備接地。 然後，我們將討論人身安全，包括為保護自己和電腦而移走珠寶，適當的舉陞技術和重量限制以及移去電源。 最後，我們將涵蓋電氣消防安全，陰極射線管（CRT）安全和處置，電纜管理以及地方政府法規合規性。</p>
<p></p>
<p>p.20</p>
<p>Operational Procedures: Electrical Safety</p>
<p>操作步驟：電氣安全</p>
<p>Electricity is a significant hazard in working with computer systems and tools. Electricity is required to make workstations operate, but if you are not careful, electricity can cause serious injury to you and major damage to the computer you are working on.</p>
<p>With regard to human injury, technicians can receive an electrical shock from computers or electrical outlets if special care is not taken when working with them. It is important to check all the power outlets to ensure they are working properly. When checking the outlets, you should verify that the outlet is providing the correct amount of power. If you are working in the United States, then you should expect to receive a voltage of 115 VAC to 120 VAC (volts of alternating current) from the power outlets in an office or home. This can be verified using a simple three-prong tester, voltmeter, or multimeter. Procedurally, you must never pull the cords out by the wires, as this can cause damage and fraying of the cables. Instead, you should plug in and remove cables by the plug on the end of the cord. It is important that you never use a frayed or damaged power cable</p>
<p>電力是使用電腦系統和工具的重大危險。要使工作站正常工作，必須通電，但是如果不小心，電流可能會對您造成嚴重傷害並嚴重損害正在使用的計算機。</p>
<p>關於人身傷害，如果在操作電腦或電源插座時未特別注意，則技術人員可能會從電腦或電源插座中遭受電擊。檢查所有電源插座以確保它們正常工作很重要。檢查插座時，應驗證插座是否提供了正確的電量。如果您在美國工作，則應該期望從辦公室或家庭的電源插座接收到115 VAC至120 VAC（交流電壓）的電壓。可以使用簡單的三叉測試儀，電壓表或萬用表進行驗證。程序上，切勿將電線從電線中拉出，因為這會導致電纜損壞和磨損。相反，您應該插入插頭並通過電源線末端的插頭拔出電纜。切勿使用磨損或損壞的電源線，這一點很重要</p>
<p>In addition to keeping themselves safe, technicians need to keep computers safe from electrical damage. It is common to use a surge protector to protect computers from power spikes or surges. A power strip is not the same thing as a surge protector. Surge protectors are rated in joules (J), a unit of energy. The rating indicates the number of joules the surge protector can absorb before failure. A higher rating indicates greater protection for the computer. Also, you must not overload the surge protectors, and must never daisy-chain them, or plug one surge protector into another: this causes higher amperage draws that can lead to fires.</p>
<p>除了保護自己的安全外，技術人員還需要保護電腦免受電氣損壞。 通常使用電湧保護器來保護電腦免受電源尖峰或電湧的影響。 配電盤與電湧保護器不是一回事。 電湧保護器的額定功率單位為焦耳（J）。 額定值表示電湧保護器在故障之前可以吸收的焦耳數。 額定值越高，表示對電腦的保護越高。 另外，您一定不能使電湧保護器過載，也不能以菊花鏈的方式將其電湧，或將一個電湧保護器插入另一個電湧保護器：這會導致電流消耗增加，從而引發火災。</p>
<p>If continuous power to a workstation is necessary, you can use an uninterruptible power supply (UPS). A UPS should never be used for laser printers, as it draws too much power through the UPS and can cause damage to the printer.</p>
<p>如果需要為工作站持續供電，則可以使用不間斷電源（UPS）。 切勿將UPS用於激光打印機，因為它會通過UPS消耗過多功率，並可能損壞印刷機。</p>
<p><img alt="Photograph of an electrical outlet with an extension    plugged into a second extension with multiple devices plugged into it." src="https://oli.cmu.edu/repository/webcontent/d826575d0a0001dc3e9f244fa018c560/PCH02/webcontent/PCH02/image1.jpeg"/></p>
<p>When working with a computer, the largest amount of voltage you will find is located inside the computer’s power supply unit (PSU). You should never disassemble a PSU; when it is broken, simply replace the entire unit. Power supply units are relatively inexpensive, so it is a best practice to simply replace them. Some technicians wonder why they should not disassemble or open the PSU and try to fix it, but the reason is simple — it is very dangerous. A PSU has numerous electrical components that allow it to convert the high-voltage 115-120 VAC (or 230-240 VAC) power into the 12 VDC (volts direct current) that is usable by the computer. Some of these components are capacitors, which cause the power supply to retain lots of voltage (up to 10,000 volts or more) even after the computer is turned off and even after the computer and PSU are unplugged. Therefore, if you want to see the inside of a PSU, search for it on the Internet and look at a picture. It is much safer.</p>
<p>使用電腦時，您會發現最大的電壓位於計算機的電源設備（PSU）內部。 您切勿拆卸電源設備； 損壞時，只需更換整個單元。 電源設備相對便宜，因此最佳實踐是簡單地更換它們。 一些技術人員想知道為什麼不應該拆卸或打開PSU並嘗試對其進行修復，但是原因很簡單-這非常危險。 PSU具有許多電氣組件，可將115-120 VAC（或230-240 VAC）高壓電源轉換為計算機可使用的12 VDC（直流電壓）。 這些組件中的一些是電容器，即使在關閉電腦後以及拔下電腦和PSU的電源後，電源也會保持大量電壓（最高10,000伏或更高）。 因此，如果要查看PSU的內部，請在Internet上搜索並查看圖片。 這更安全。</p>
<p><img alt="" height="550" src="/images/image2.png" width="550"/></p>
<p></p>
<p>p.21</p>
<p>Power Supplies</p>
<p>電源</p>
<p>Technicians should use surge protectors or surge suppressors to protect computers from power spikes and surges. These devices are specifically designed to absorb overvoltage conditions that would damage computers, printers, and monitors. While these devices will protect the computer from damage resulting from an overvoltage condition, they do not protect it from an undervoltage condition. Undervoltage is a condition that occurs when insufficient voltage is provided by the outlet to the computer. In situations where it is essential that the computer not lose power, technicians must install an uninterruptible power supply (UPS) to provide emergency power when a power failure (blackout) occurs or an undervoltage condition (brownout) occurs. The UPS runs the computer from its internal battery continuously and recharges the UPS’s battery while power is available. Once power is lost, the UPS continues to power the computer for up to 15 minutes (purportedly). This provides the user enough time to save work and safely power down the workstation. Another device that helps in undervoltage conditions is the standby power supply (SPS), which runs the computer directly from the wall outlet (AC power), but switches to the battery in less than a millisecond when a power outage occurs. An SPS device does not provide constant power, like a UPS device. For this reason, most technicians prefer UPS devices over SPS devices, so UPS devices are much more common in the marketplace.</p>
<p>技術人員應使用電湧保護器或電湧抑制器來保護計算機免受電湧和電湧的影響。這些設備經過專門設計，可以吸收可能損壞<span>電腦</span>，打印機和顯示器的過電壓情況。儘管這些設備可以保護<span>電腦</span>免受過壓狀態造成的損壞，但它們不能保護計算機免受欠壓狀態的影響。當計算機的插座提供的電壓不足時，就會發生欠壓情況。在必須確保<span>電腦</span>不掉電的情況下，技術人員必須安裝不間斷電源（UPS），以在發生電源故障（停電）或發生欠壓情況（斷電）時提供應急電源。 UPS會使用其內部電池連續運行<span>電腦</span>，並在有電時為UPS的電池充電。一旦斷電，UPS將繼續為<span>電腦</span>供電長達15分鐘（據稱）。這為用戶提供了足夠的時間來節省工作並安全地關閉工作站電源。備用電源（SPS）是在欠壓情況下提供幫助的另一種設備，該備用電源直接從壁裝電源插座（交流電源）運行<span>電腦</span>，但在斷電時不到一毫秒即可切換到電池。 SPS設備不像UPS設備那樣提供恆定功率。因此，大多數技術人員更喜歡UPS設備而不是SPS設備，因此UPS設備在市場上更為普遍。</p>
<p><img alt="" height="391" src="/images/image3.png" width="550"/></p>
<p>Uninterruptible power supplies are rated in various ways, including their runtimes, network support capabilities, automatic shutdown capabilities, and surge suppression. The runtime dictates the amount of time a computer will keep running on power from the UPS’s battery once source power is removed. Usually, you want to use a UPS with at least 15 minutes of runtime support. The bigger the battery, the longer the runtime. The runtime is calculated based on volt-amps, which is discussed in more detail in a later section. UPS devices can also have software that allows them to be connected to the network. Therefore, when the UPS notices a drop in power, it can send out a message to the users that the network is being shut down because of power loss. Some UPS devices support automatic shutdown of the connected computer or server, so that once a switch to battery power occurs, the UPS sends a shutdown signal to the connected machine. Finally, most UPS devices also provide surge suppression capabilities, rated in joules.</p>
<p>The last type of device technicians can use is called a power conditioner or line conditioner. These devices do not have any battery backup capability, but can rectify the power from a dirty power condition (where power fluctuates greatly) to a steady 115-120 VAC power condition. These devices can raise undervoltage conditions to normal levels, as well as cut overvoltage conditions back down to standard levels. This is very important if your systems are going to run from a backup generator, or if you are operating in an area with unstable power (such as in some developing countries).</p>
<p>不間斷電源的額定方式有多種，包括其運行時間，網絡支持功能，自動關機功能和電湧抑制。運行時間規定了斷開電源後<span>電腦</span>將繼續使用UPS電池供電的時間。通常，您要使用具有至少15分鐘運行時間支持的UPS。電池越大，運行時間越長。運行時間是基於伏安計算的，這將在後面的部分中詳細討論。 UPS設備還可以具有允許其連接到網絡的軟件。因此，當UPS注意到電源中斷時，它可以向用戶發送一條消息，通知您由於斷電而導致網絡正在關閉。某些UPS設備支持所連接的<span>電腦</span>或服務器的自動關機，因此一旦切換到電池電源，UPS就會向所連接的<span>電腦</span>發送關機信號。最後，大多數UPS設備還提供以焦耳為單位的電湧抑制功能。</p>
<p>技術人員可以使用的最後一種設備稱為功率調節器或線路調節器。這些設備沒有任何備用電池功能，但是可以將電源從骯髒的電源狀況（電源波動很大）整流為穩定的115-120 VAC電源狀況。這些器件可將欠壓條件提高到正常水平，並將過壓條件降低迴標準水平。如果您的系統要使用備用發電機運行，或者您在電力不穩定的區域（例如在某些發展中國家）運行，則這非常重要。</p>
<p></p>
<p>p.22</p>
<p>Power Variation</p>
<p>功率變化</p>
<p>It is important to understand the technical terms for the various undervoltage and overvoltage conditions that could exist, such as power surge, dirty power, sag, brownout, and blackout, as well as the device that provides protection to the computers and computer system equipment when these conditions occur. A power surge occurs when a short increase in AC voltage happens, such as from 120 VAC to 130 VAC. To protect computers from this condition, you would use a surge suppressor. Dirty power occurs when AC voltage continuously fluctuates, for example between 113 VAC and 130 VAC. To correct this condition, an in-line UPS or line conditioner should be used. A sag occurs when an unexpected short decrease in voltage occurs. This can be corrected with either a line conditioner or a UPS. A brownout is a more significant, larger voltage drop than a sag, and could result in the voltage being cut in half (such as 120 VAC dropping to 60 VAC). This is too much for a line conditioner to handle, so a UPS would be required. Finally, if there is a complete loss of power, this is called a blackout. Only a UPS can solve this problem, but only for a short duration (purportedly about 15 minutes). If operations must continue after this, you would need to switch to a backup generator to provide the power required.</p>
<p>重要的是要理解可能存在的各種欠壓和過壓條件的技術術語，例如電湧，脹電源，跌落，掉電和停電，以及在以下情況下為<span>電腦</span>和<span>電腦</span>系統設備提供保護的設備：這些情況發生。當交流電壓發生短暫升高（例如從120 VAC到130 VAC）時，就會發生電湧。為了保護<span>電腦</span>免受這種情況的影響，應使用電湧抑制器。當交流電壓持續波動（例如在113 VAC和130 VAC之間）時，會產生臟電。要糾正這種情況，應使用串聯式UPS或線路調節器。當電壓出現意外的短時下降時，就會發生下垂。可以使用電源調節器或UPS進行糾正。掉電比下垂更為顯著，更大的電壓降，並且可能導致電壓降低一半（例如120 VAC降至60 VAC）。對於線路調節器來說，這太多了，因此需要UPS。最後，如果完全斷電，則稱為停電。只有UPS可以解決此問題，但只能持續很短的時間（據說大約15分鐘）。如果此後必須繼續操作，則需要切換到備用發電機以提供所需的電源。</p>
<p></p>
<p>p.23</p>
<p>Protecting People and Property</p>
<p>保護人身和財產</p>
<p>Electricity can be a common cause of fire, especially if the electrical circuits are overloaded. If a computer or outlet catches on fire, you should use a class C extinguisher, which is a carbon dioxide (CO2)-based extinguisher. You should not attempt to extinguish an electrical fire with water, because water conducts electricity. If the fire is small, you may use a portable extinguisher to put the fire out immediately, but you should never put yourself in harm’s way. If the fire begins to get out of control, everyone should move to a safe area and call 911 for help immediately. Some server rooms have built-in fire suppression systems that release CO2 or halon when a fire alarm occurs. Halon is a toxic compressed gas, in liquid form, that chemically disrupts a combustion reaction. A CO2 system is designed to flood the room with carbon dioxide in order to remove all oxygen from the room, thereby killing the fire. People who are working in a server room and hear the fire alarm sounding must immediately vacate the area and get to a safe location. This is a life-threatening situation, both because of the fire and because of the potentially lethal nature of the fire-suppression systems.</p>
<p>電力可能是引起火災的常見原因，尤其是在電路過載的情況下。如果<span>電腦</span>或插座著火，則應使用C類滅火器，它是一種基於二氧化碳（CO2）的滅火器。您不應嘗試用水滅火，因為水可以導電。如果火很小，則可以使用便攜式滅火器將火立即撲滅，但絕對不要傷害自己。如果火勢開始失控，所有人應移至安全區域並立即撥打911尋求幫助。一些服務器機房具有內置的滅火系統，當發生火災警報時，這些系統會釋放CO2或哈龍。哈龍是有毒的壓縮氣體，呈液態，化學上會破壞燃燒反應。 CO2系統設計用於向房間充斥二氧化碳，以清除房間中的所有氧氣，從而撲滅大火。在服務器機房工作並聽到火警警報的人員必須立即離開該區域並到達安全位置。由於起火以及滅火系統的潛在致命特性，這是威脅生命的情況。</p>
<p></p>
<p>p.24</p>
<p>Operational Procedures: Electrostatic Discharge</p>
<p>操作步驟：靜電放電</p>
<p>Another major safety hazard for computer systems and components is electrostatic discharge (ESD). ESD damage is caused by the discharge of static electricity that has been built up by the human body in the course of everyday events, such as walking, standing and sitting at our desks, and other activities. In drier (less humid) environments, static electricity builds up more quickly and becomes more of an issue. This is especially true during winter months. While static electricity cannot directly harm humans very much, it can be deadly to computer components. A person builds static electricity that can reach 20,000 to 25,000 volts, but is of a low amperage (making it safe for humans). When you touch something of lower electrical potential, such as the metal case of the computer or the circuit board of an expansion card, the static electricity in your body is discharged into that component, causing damage. If you touch a circuit board without taking ESD precautions, ESD may occur and cause permanent failure or an intermittent failure of the component.</p>
<p>You can protect computer equipment from ESD fairly easily. First, you should use an antistatic wrist strap, also known as an ESD strap.</p>
<p><span>電腦</span>系統和組件的另一個主要安全隱患是靜電放電（ESD）。 ESD損壞是由人體在日常活動（例如走路，站立和坐在辦公桌旁以及其他活動）過程中積聚的靜電釋放引起的。在乾燥（濕度較低）的環境中，靜電積聚更快，成為一個更大的問題。在冬季尤其如此。儘管靜電不會直接對人類造成太大傷害，但對<span>電腦</span>組件而言可能是致命的。一個人積聚的靜電可以達到20,000到25,000伏，但電流強度很低（對人類安全）。當您觸摸電勢較低的物體（例如計算機的金屬外殼或擴展卡的電路板）時，體內的靜電會釋放到該組件中，從而造成損壞。如果在未採取ESD預防措施的情況下觸摸電路板，則可能會發生ESD，並導致組件永久性故障或間歇性故障。</p>
<p>您可以相當容易地保護<span>電腦</span>設備免受ESD的影響。首先，應使用防靜電腕帶，也稱為ESD腕帶。</p>
<p><img alt="" height="364" src="/images/image4.png" width="550"/></p>
<p>These devices are very inexpensive and are the best method of protecting equipment against ESD. To be effective, one end of the strap must be grounded (by clipping it to something such as to the bare metal of the computer case), and the other end is placed around your wrist like a bracelet. This continually causes a discharge from the body to the computer case, thereby protecting the internal computer components. Because of the high voltage present inside a cathode ray tube (CRT) monitor, you should not wear an ESD wrist strap when working inside a CRT monitor.</p>
<p>If you do not have an ESD strap, you can employ the second precautionary method, called grounding against the chassis. In this method, you touch any unpainted metal part of the computer case to discharge the static electricity from your body before touching the sensitive components (such as expansion cards). This method is quite good, but you must remember to ground yourself against the case every time before touching a component. The last precautionary method is to use anti-static bags. This procedure is useful during transport of various components. Basically, you place the components and cards inside the anti-static bag to protect them from ESD while you are carrying them from one location to another.</p>
<p>這些設備非常便宜，是保護設備免受ESD影響的最佳方法。為使之有效，必須將腕帶的一端接地（通過將其修剪到諸如<span>電腦</span>殼裸露的東西上），另一端像手鐲一樣放在手腕上。這連續地導致從身體向<span>電腦</span>機殼的放電，從而保護了內部<span>電腦</span>組件。由於陰極射線管（CRT）顯示器內部存在高壓，因此在CRT顯示器內部工作時，請勿佩戴ESD腕帶。</p>
<p>如果沒有ESD綁帶，則可以採用第二種預防方法，即與機箱接地。通過這種方法，在觸摸敏感組件（例如擴展卡）之前，請觸摸<span>電腦</span>機箱上任何未上漆的金屬部分，以從身上釋放靜電。這種方法相當不錯，但是每次觸摸組件之前，您都必須記住要使自己始終與外殼接觸。最後一種預防方法是使用防靜電袋。此過程在運輸各種組件時很有用。基本上，將組件和卡從一個位置搬運到另一位置時，請將其放置在防靜電袋中，以防靜電。</p>
<p><img alt="" height="610" src="/images/image5.png" width="550"/></p>
<p>To prevent ESD we must ensure we handle components properly. Never touch the face of the cards where the components and wiring are located; only handle cards by the edges. Additionally, always use proper ESD straps or grounding techniques before handling the cards. You also should remove jewelry and avoid loose clothes, since they may get caught in the computer or inadvertently cause a static charge to be transferred into a component. Another great technique is the use of an anti-static mat or workbench. Many server rooms and IT shops have these mats installed, and they provide a good method of keeping yourself grounded while working. You can also raise the humidity of the room to minimize the chances of static build-up. Most computer server rooms keep humidity between 40 and 50 percent to minimize electrostatic build-up, but often you will not have control over the humidity as a technician. You also want to avoid carpeted areas when possible, as walking across carpet creates a faster buildup of static electricity in the body. Finally, never use electrical or magnetic tools on the workstation, as the electrical motors from drills, impact wrenches, and vacuums create static electricity that can be discharged into fragile components.</p>
<p>為了防止ESD，我們必須確保正確處理組件。切勿觸摸組件和配線所在的卡的表面；只能處理邊緣的卡。此外，在處理插卡之前，請始終使用正確的ESD腕帶或接地技術。您還應卸下珠寶首飾並避免穿寬鬆的衣服，因為它們可能會卡在<span>電腦</span>中或無意間將靜電轉移到組件中。另一個很棒的技術是使用防靜電墊或工作台。許多服務器機房和IT商店都安裝了這些墊子，它們是在工作時保持接地的一種好方法。您還可以提高房間的濕度，以最大程度減少靜電積聚的機會。大多數<span>電腦</span>服務器機房將濕度保持在40％到50％之間，以最大程度地減少靜電積聚，但是作為技術人員，您通常無法控制濕度。您還希望盡可能避免舖有地毯的區域，因為在地毯上行走會在體內更快地積聚靜電。最後，切勿在工作站上使用電動或磁性工具，因為鑽頭，衝擊扳手和真空吸塵器產生的電動機會產生靜電，這些靜電會排放到易碎的部件中。</p>
<p></p>
<h1>HomeWork 2</h1>
<h2>作業一</h2>
<p>一乙數列(python)</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_924430">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
<div class="line number7 index6 alt2">7</div>
<div class="line number8 index7 alt1">8</div>
<div class="line number9 index8 alt2">9</div>
<div class="line number10 index9 alt1">10</div>
<div class="line number11 index10 alt2">11</div>
<div class="line number12 index11 alt1">12</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py keyword">import</code> <code class="py plain">urllib.request</code></div>
<div class="line number2 index1 alt1"><code class="py comments">#導入urllib.request</code></div>
<div class="line number3 index2 alt2"><code class="py plain">target_url </code><code class="py keyword">=</code> <code class="py string">"https://nfulist.herokuapp.com/?semester=1091&amp;courseno=0776"</code></div>
<div class="line number4 index3 alt1"><code class="py comments">#設target_url = "網址"</code></div>
<div class="line number5 index4 alt2"><code class="py plain">cp1b </code><code class="py keyword">=</code> <code class="py plain">[]</code></div>
<div class="line number6 index5 alt1"><code class="py comments">#設cp1b=數列</code></div>
<div class="line number7 index6 alt2"><code class="py keyword">for</code> <code class="py plain">line </code><code class="py keyword">in</code> <code class="py plain">urllib.request.urlopen(target_url):</code></div>
<div class="line number8 index7 alt1"><code class="py comments">#重複打開target_url的迴圈定義line</code></div>
<div class="line number9 index8 alt2"><code class="py spaces">    </code><code class="py plain">cp1b.append(</code><code class="py functions">int</code><code class="py plain">(line.decode(</code><code class="py string">'utf-8'</code><code class="py plain">).rstrip()))</code></div>
<div class="line number10 index9 alt1"><code class="py spaces">    </code><code class="py comments">#把line重新編碼加進cp1b(數列)   註:rstrip()刪除字尾符號</code></div>
<div class="line number11 index10 alt2"><code class="py functions">print</code><code class="py plain">(cp1b)</code></div>
<div class="line number12 index11 alt1"><code class="py comments">#印出cp1b</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p></p>
<p>成果:</p>
<p><img caption="false" height="88" src="https://40823152.github.io/cp2020/images/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202020-11-28%20205145.png" width="600"/></p>
<p>解題步驟:</p>
<p>1. 導入物件</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_981881">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py keyword">import</code> <code class="py plain">urllib.request</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>2.設url(要打開的網址)</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_148202">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">target_url </code><code class="py keyword">=</code> <code class="py string">"https://nfulist.herokuapp.com/?semester=1091&amp;courseno=0776"</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>3.設數列</p>
<div>
<div class="syntaxhighlighter html" id="highlighter_89389">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="html plain">cp1b = []</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>4.設line為打開url的迴圈，並且使數列cp1b增加編碼後的line，最後刪除字尾符號</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_782289">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py keyword">for</code> <code class="py plain">line </code><code class="py keyword">in</code> <code class="py plain">urllib.request.urlopen(target_url):</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div>
<div class="syntaxhighlighter py" id="highlighter_979400">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py plain">cp1b.append(</code><code class="py functions">int</code><code class="py plain">(line.decode(</code><code class="py string">'utf-8'</code><code class="py plain">).rstrip()))</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>5.印出1b的數列</p>
<div>
<div class="syntaxhighlighter py" id="highlighter_816500">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="py functions">print</code><code class="py plain">(cp1b)</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p></p>
<p>from random import shuffle<br/>list = [40523138, 40523148, 40723217, 40728238, 40823148, 40823152, 40923201, 40923202, 40923203, 40923204, 40923205, 40923206, 40923207, 40923208, 40923209, 40923210, 40923211, 40923212, 40923213, 40923214, 40923216, 40923217, 40923218, 40923219, 40923220, 40923221, 40923223, 40923224, 40923225, 40923226, 40923227, 40923228, 40923229, 40923230, 40923231, 40923232, 40923233, 40923234, 40923235, 40923236, 40923237, 40923238, 40923239, 40923240, 40923241, 40923242, 40923243, 40923244, 40923245, 40923246, 40923247, 40923248, 40923249, 40923250, 40923251, 40923252, 40923253]<br/>shuffle(list)<br/>n = 5<br/>m = int(len(list)/n)<br/>list2 = []<br/>for i in range(0, len(list),m):<br/> list2.append(list[i:i+m])<br/>print(list2)</p>
<p></p>
<h2>作業一-2</h2>
<div class="line number1 index0 alt2">
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">InputElement studListUrl = querySelector("#studListUrl");
  String studUrl;
  InputElement courseName = querySelector("#courseName");
  String cName;
  // 將 Label 改為 Textarea, 避免產生過程結果嵌入所在頁面
  TextAreaElement output = querySelector("#output");
   
main() {
  querySelector("#submit").onClick.listen((e) =&gt; grouping());
}
   
grouping() {
  output.innerHtml = "";
   
  if (studListUrl.value != "") {
    studUrl = studListUrl.value;
  } else {
    studUrl = 'https://nfulist.herokuapp.com';
  }
   
  if (courseName.value != "") {
    cName = courseName.value;
  } else {
    cName = "cp2020";
  }
   
  // 組序由 1 開始
  int gth = 1;
  // 迴圈序號變數
  int i;
  int j;
  int total;
  int inc;
  // 每組學員暫存數列
  var gpList = [];
  // 全班分組數列
  var group = [];
  // 各組人數數列
  var numList = [];
   
  HttpRequest.getString(studUrl).then((String resp) {
    // 利用 trim() 去除字串最後的跳行符號, 之後再利用 split() 根據 \n 轉為數列
    var studList = resp.trim().split("\n");
    // 數列利用 shuffle() 方法以隨機方法弄亂順序
    studList.shuffle();
    total = studList.length;
    output.text += "全班總計" + total.toString() + " 人\n";
    numList = getNumList(studList.length);
    inc = 0;
    for (i in numList){
      // 列印區隔符號
      output.text += '=' * 20 + "\n";
      output.text += "group $gth 有 " + i.toString() + " 人: \n";
      gpList = [];
      for (j = 0; j &lt; i; j++){
        output.text += studList[j+inc] + "\n";
        // 在各分組數列中加入將對應的學員學號
        gpList.add(studList[j+inc]);
      }
      gth = gth + 1;
      inc = inc + j;
        //output.text += studList[j] + "\n";
        // 逐步將各組暫存的分組數列加入全班分組數列中
      gpList.sort();
      group.add(gpList);
    }
    // 列出全班分組數列
    output.text += group.toString() + "\n";
    // 列出已經排序後的分組名單
    output.text += '=' * 25 + "\n";
    output.text += '以下為排序後的各組成員名單: \n';
    gth = 1;
    /*
    404231
    s4052
    4062
    s4072
    4082
    5072
    5083
    */
    // 先列出純文字以 \n 跳行組員資料
    for (i=0; i &lt; group.length; i++){
      // 列印區隔符號
      output.text += '=' * 20 + "\n";
      output.text += "group $gth \n";
      gpList = [];
      for (j=0; j &lt; group[i].length; j++){
        output.text += group[i][j] + "\n";
      }
      gth = gth + 1;
    }
      
    gth = 1;
    // 最後列出超文件以 &lt;br\&gt; 跳行組員資料, 包含倉儲與網站
    for (i=0; i &lt; group.length; i++){
      // 列印區隔符號
      output.text += '\n' + '=' * 30 + "&lt;br \&gt;";
      output.text += "group $gth &lt;br \&gt;";
      gpList = [];
      for (j=0; j &lt; group[i].length; j++){
          if (group[i][j].startsWith('4052') || group[i][j].startsWith('4072')) {
              output.text += "Repository: &lt;a href='https://github.com/s" +
                                      group[i][j] + "/" + cName + "'&gt;" + group[i][j] + 
                                      "&lt;/a&gt;" + " | Site: &lt;a href='https://s" + group[i][j] +
                                      ".github.io/" + cName + "'&gt;" + group[i][j] +
                                      "&lt;/a&gt;&lt;br \&gt;";
          }
          else {
              output.text += "Repository: &lt;a href='https://github.com/" +
                                      group[i][j] + "/" + cName +"'&gt;" + group[i][j] +
                                      "&lt;/a&gt;" + " | Site: &lt;a href='https://" + group[i][j] +
                                      ".github.io/" + cName + "'&gt;" + group[i][j] +
                                      "&lt;/a&gt;&lt;br \&gt;";
          }
      }
      gth = gth + 1;
    }
  });
}
   
List getNumList(int total){
  // total student number
  // int total = 65;
  // initial each group expect to be "eachGrp" number of people
  int eachGrp = 10;
  // may divide into "grpNum" number of group
  int grpNum = total ~/ eachGrp;
  // vacant list
  var splits = [];
  // find remainder when total number divid into "grpNum" number of group
  int remainder = total % grpNum;
  // number of people in one group by calculation
  int calGrp = total ~/ grpNum;
   
  for (int i = 0; i &lt; grpNum; i++) {
    splits.add(calGrp);
  }
  //print(splits);
   
  for (int i = 0; i &lt; remainder; i++) {
    splits[i] += 1;
  }
  //print(splits);
  return splits;
 }&lt;/pre&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"&gt;&lt;h4&gt;亂數分組:&lt;/h4&gt;
學員名單 URL: &lt;input type="text" id="studListUrl" size="60" value="https://nfulist.herokuapp.com"&gt;&lt;br /&gt;
課程代號: &lt;input type="text" id="courseName" size="15" value="cp2020"&gt;&lt;br /&gt;
&lt;input type="submit" value="開始分組" id="submit"&gt;&lt;br /&gt;
&lt;textarea id="output" cols="80" rows="10"&gt;&lt;/textarea&gt;&lt;/pre&gt;
&lt;p&gt;style.css&lt;/p&gt;
&lt;pre class="brush:css;auto-links:false;toolbar:false" contenteditable="false"&gt;body {
  color: white;
  font-size: 20px;
}
  
input, select, textarea {
font-size: 100%;
}&lt;/pre&gt;
&lt;p&gt;even_grouping.py&lt;/p&gt;
&lt;pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"&gt;import random
import requests
   
# getNumList 主要在每組最低人數下, 將不足 10 人的分組
# 平均分配至各組
def getNumList(total, eachGrp=10):
    # total is the number of students
    # each group at least 10 students
    #eachGrp = 10;
    # may divide into "grpNum" number of group
    grpNum = total // eachGrp;
    # check grpNum
    #print(grpNum)
    # vacan list
    splits = []
    # find remainder when total number divid into "grpNum" number of group
    remainder = total % grpNum
    # number of people in one group by calculation
    calGrp = total // grpNum
       
    for i in range(grpNum):
        splits.append(calGrp)
           
    # check first splits
    #print(splits)
     
    for i in range(remainder):
        splits[i] += 1
       
    # check final splits
    #print(splits);
    return splits;
   
# 儲存學生名單資料的 url
target_url = "http://mde.tw/cp2020/downloads/get_student_list/2020spring_cd_2a_list.txt"
# 利用 requests 讀取 url 中的資料
f = requests.get(target_url)
# get student list from target_url
# 利用 splitlines() 將資料放入數列 studList
studList = f.text.splitlines()
# 每組預計分組的最低人數
num_in_one_group = 10
# 每組學員暫存數列
gpList = []
# 全班分組數列
group = []
# 各組人數數列
numList = []
# get numList
numList = getNumList(len(studList), num_in_one_group)
# check numList
# 列出已經補齊的各組人數數列
print("預計各組人數數列:" + str(numList))
   
output = ""
gth = 1
inc = 0
   
# 弄亂 studList
random.shuffle(studList)
output += "以下為尚未排序前的各組學員學號: \n"
for i in numList:
    # 列印區隔符號
    output += '=' * 20 + "\n";
    output += "group " + str(gth) + " 有 " + str(i) + " 人: \n"
    # 每組學員暫存數列, 在此 reset
    gpList = []
    for j in range(i):
        output += studList[j+inc] + "\n"
        # 在各分組數列中加入將對應的學員學號
        gpList.append(studList[j+inc])
         
    gth = gth + 1
    inc = inc + j
    # 將各組學員數列依照學號排序
    gpList.sort()
    group.append(gpList)
   
# 列出尚未排序前的分組結果
print(output)
# 列出已經完成排序的分組數列
print("已經排序後的分組數列:" + str(group))
   
output = ""
# 列出已經排序後的分組名單
output += '=' * 25 + "\n"
output += '以下為排序後的各組成員名單:\n'
gth = 1
   
# 先列出純文字以 \n 跳行組員資料
for i in range(len(group)):
    # 列印區隔符號
    output += '=' * 20 + "\n"
    output += "group" + str(gth) + "\n"
    gpList = []
       
    for j in range(len(group[i])):
        output += str(group[i][j]) + "\n"
         
    gth = gth + 1
       
print(output)&lt;/pre&gt;
&lt;h4&gt;使用 Brython&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://mde.tw/lab/content/Python.html"&gt;http://mde.tw/lab/content/Python.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"&gt;# 利用 Brython 內建的 open 開啟 url 後, 以 read() 將資料取出
output = open('http://mde.tw/cp2020/downloads/get_student_list/2020spring_cd_2a_list.txt').read()
</pre>
</div><h1>HomeWork 3</h1>
<p><span>23、24、25</span></p><h2>Exercise</h2>
<p>23.File Overlap</p>
<p>24.Draw A Game Board</p>
<p>25.Guessing Game Two</p><h3>23.File Overlap</h3>
<p>Exercise 23</p>
<p>Given two<span> </span><code class="highlighter-rouge">.txt</code><span> </span>files that have lists of numbers in them, find the numbers that are overlapping.<span> </span><a href="http://www.practicepython.org/assets/primenumbers.txt">One<span> </span><code class="highlighter-rouge">.txt</code><span> </span>file</a><span> </span>has a list of all prime numbers under 1000, and<span> </span><a href="http://www.practicepython.org/assets/happynumbers.txt">the other<span> </span><code class="highlighter-rouge">.txt</code><span> </span>file</a><span> </span>has a list of happy numbers up to 1000.</p>
<p>練習23<br/>給定兩個帶有數字列表的.txt文件，請查找重疊的數字。 一個.txt文件包含一個所有1000以下的質數的列表，另一個.txt文件包含一個最大為1000的幸福數字的列表。</p>
<p>(If you forgot, prime numbers are numbers that can’t be divided by any other number. And yes, happy numbers are a real thing in mathematics - you can<span> </span><a href="http://en.wikipedia.org/wiki/Happy_number">look it up on Wikipedia</a>. The explanation is easier with an example, which I will describe below.)</p>
<p>（如果您忘記了，質數是不能除以任何其他數字的數字。是的，快樂數是數學中的真實事物-您可以在Wikipedia上查找它。通過一個例子可以更容易地解釋這一點，我 將在下面進行說明。）</p>
<p></p>
<p></p>
<p></p>
<p></p>
<h3>24.Draw A Game Board</h3>
<p>Exercise 24<br/>This exercise is Part 1 of 4 of the Tic Tac Toe exercise series. The other exercises are: Part 2, Part 3, and Part 4.</p>
<p>練習24<br/>此練習是Tic Tac Toe練習系列4的第1部分。 其他練習是：第2部分，第3部分和第4部分。</p>
<p>Time for some fake graphics! Let’s say we want to draw game boards that look like this:</p>
<p>--- --- --- <br/>| | | | <br/> --- --- --- <br/>| | | | <br/> --- --- --- <br/>| | | | <br/> --- --- --- <br/>This one is 3x3 (like in tic tac toe). Obviously, they come in many other sizes (8x8 for chess, 19x19 for Go, and many more).</p>
<p>是時候購買一些假圖形了！ 假設我們要繪製如下游戲板：</p>
<p>---<br/>| | | |<br/> ---<br/>| | | |<br/> ---<br/>| | | |<br/> ---<br/>這是3x3（就像井字遊戲一樣）。 顯然，它們有許多其他尺寸（國際象棋為8x8，圍棋為19x19等）。</p>
<p>Ask the user what size game board they want to draw, and draw it for them to the screen using Python’s print statement.</p>
<p>詢問用戶他們想繪製什麼尺寸的遊戲板，並使用Python的print語句將其繪製到屏幕上。</p>
<p>Remember that in Python 3, printing to the screen is accomplished by</p>
<p>print("Thing to show on screen")<br/>Hint: this requires some use of functions, as were discussed previously on this blog and elsewhere on the Internet, like this TutorialsPoint link.</p>
<p>請記住，在Python 3中，打印到屏幕是通過以下方式完成的：</p>
<p>打印（“顯示在屏幕上的東西”）<br/>提示：這需要某種功能的使用，如本博客之前和Internet上其他地方所討論的，例如TutorialsPoint鏈接。</p>
<p><span></span></p>
<p><span></span></p>
<p><span></span></p>
<p><span></span></p>
<h3>25.Guessing Game Two</h3>
<p>Exercise 25</p>
<p>In<span> </span><a href="https://www.practicepython.org/exercise/2014/04/02/09-guessing-game-one.html">a previous exercise</a>, we’ve written a program that “knows” a number and asks a user to guess it.</p>
<p>This time, we’re going to do exactly the opposite. You, the user, will have in your head a number between 0 and 100. The program will guess a number, and you, the user, will say whether it is too high, too low, or your number.</p>
<p>At the end of this exchange, your program should print out how many guesses it took to get your number.</p>
<p>As the writer of this program, you will have to choose how your program will strategically guess. A naive strategy can be to simply start the guessing at 1, and keep going (2, 3, 4, etc.) until you hit the number. But that’s not an optimal guessing strategy. An alternate strategy might be to guess 50 (right in the middle of the range), and then increase / decrease by 1 as needed. After you’ve written the program, try to find the optimal strategy! (We’ll talk about what is the optimal one next week with the solution.)</p>
<p><span>在上</span><a href="https://www.practicepython.org/exercise/2014/04/02/09-guessing-game-one.html"><span>一個練習中</span></a><span>，我們編寫了一個程序，該程序“知道”一個數字並要求用戶猜測它。</span></p>
<p><span><span>這次，我們將做相反的事情。</span><span>您（用戶）的腦海中會有一個介於0到100之間的數字。程序將猜測一個數字，而您（用戶）將說出它是太高，太低還是您的數字。</span></span></p>
<p><span><span>交換結束後，您的程序應打印出獲得號碼所需的猜測次數。</span></span></p>
<p><span><span>作為該程序的作者，您將不得不選擇您的程序將如何進行戰略性猜測。</span><span>幼稚的策略可以是簡單地從1開始猜測，並繼續進行（2、3、4等），直到您得出數字為止。</span><span>但這不是最佳的猜測策略。</span><span>另一種策略是猜測50（在範圍的中間），然後根據需要增加/減少1。</span><span>編寫完程序後，嘗試找到最佳策略！</span><span>（我們將在下週討論該解決方案的最佳選擇。）</span></span></p>
<p><span><span></span></span></p>
<p><span><span>Topics and links for more information</span></span></p>
<p>(<span>更多資訊於連結和主題)</span></p>
<p>This exercise doesn’t need any functions, but it does need extensive use of variables, math, and user input.</p>
<p>You can refer to<span> </span><a href="https://www.practicepython.org/exercise/2014/01/29/01-character-input.html">this exercise on user input</a>,<span> </span><a href="https://www.practicepython.org/exercise/2014/03/26/08-rock-paper-scissors.html">this one on rock paper scissors</a>, and many others.</p>
<p>If you want to implement the optimal solution without thinking about it first, you can read this<span> </span><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">Wikipedia article on binary search</a>.</p>
<p><span>該練習不需要任何功能，但確實需要大量使用變量，數學和用戶輸入。</span></p>
<p><span><span>您可以</span></span><a href="https://www.practicepython.org/exercise/2014/01/29/01-character-input.html"><span><span>在用戶輸入上</span></span></a><span><span>參考</span><a href="https://www.practicepython.org/exercise/2014/01/29/01-character-input.html"><span>此練習</span></a><span>，</span></span><a href="https://www.practicepython.org/exercise/2014/03/26/08-rock-paper-scissors.html"><span><span>在石頭剪刀</span></span></a><span><a href="https://www.practicepython.org/exercise/2014/01/29/01-character-input.html"><span>上</span></a><span>參考</span><a href="https://www.practicepython.org/exercise/2014/01/29/01-character-input.html"><span>此練習</span></a><span>，以及其他許多參考。</span></span></p>
<p><span><span>如果您想在不首先考慮的情況下實施最佳解決方案，則可以閱讀</span></span><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm"><span><span>有關二進制搜索的Wikipedia文章</span></span></a><span><span>。</span></span></p>
<p><span><span></span></span></p>
<p>Happy coding!</p>
<p>編碼愉快!</p><h2>Solutions</h2>
<p>23.File Overlap</p>
<p>24.Draw A Game Board</p>
<p>25.Guessing Game Two</p><h3>23.File Overlap Solutions</h3>
<p>Sample solution<br/>For a simple look at the solution (without using functions and using a for loop), look no further. Read on for a solution using functions and list comprehensions, along with a detailed explanation in Python 3.</p>
<p>樣題解答<br/>為了簡單地看一下解決方案（不使用函數，也不使用for循環），別無所求。繼續閱讀以獲取使用函數和列表推導的解決方案以及Python 3中的詳細說明。</p>
<p>The solution without functions using a for loop (read on for the one with functions and the explanation)</p>
<p>沒有功能的解決方案使用for循環（繼續閱讀帶有功能和說明的解決方案）</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">primeslist = []
with open('primenumbers.txt') as primesfile:
	line = primesfile.readline()
	while line:
		primeslist.append(int(line))
		line = primesfile.readline()

happieslist = []
with open('happynumbers.txt') as happiesfile:
	line = happiesfile.readline()
	while line:
		happieslist.append(int(line))
		line = happiesfile.readline()

overlaplist = []
for elem in primeslist:
	if elem in happieslist:
		overlaplist.append(elem)
		
print(overlaplist)</pre>
<pre><br/>The solution with functions using list comprehensions (read on for the explanation):<br/>具有使用列表推導功能的解決方案（請繼續閱讀以獲取解釋）</pre>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def filetolistofints(filename):
	list_to_return = []
	with open(filename) as f:
		line = f.readline()
		while line:
			list_to_return.append(int(line))
			line = f.readline()
	return list_to_return

primeslist = filetolistofints('primenumbers.txt')
happieslist = filetolistofints('happynumbers.txt')

overlaplist = [elem for elem in primeslist if elem in happieslist]
print(overlaplist)</pre>
<pre><br/><br/></pre>
<pre><br/>The explanation<br/>The interesting thing about this problem is that it is an extension of a previous exercise asking to find the overlap of two lists. <br/>Instead of lists that are hard-coded into the file, the program will now read lists of information from files somewhere on the computer and perform the same overlap operation.<br/>說明<br/>關於此問題的有趣之處在於，它是先前練習的擴展，要求查找兩個列表的重疊部分。該程序現在將從計算機上某處的文件中讀取信息列表，並執行相同的重疊操作，而不是將這些列表硬編碼到文件中。</pre>
<p>The first thing to do is open the .txt files and save them somewhere on your computer (easiest is in the same folder as the Python file you are working in). You notice that when you look at the file, each line of the file is an integer. Next, in Python we want to open one of the files and save the contents (as integers) into a list.</p>
<p>要做的第一件事是打開.txt文件，並將其保存在計算機上的某個位置（最簡單的方法是與您正在使用的Python文件位於同一文件夾中）。您會注意到，當您查看文件時，文件的每一行都是一個整數。接下來，在Python中，我們要打開其中一個文件，然後將內容（作為整數）保存到列表中。</p>
<p>This code snippet, as taken from the Exercise 23 explanation about reading from files, will open the file and print out all the lines.</p>
<p>該代碼段摘自練習23中有關讀取文件的說明，它將打開文件並打印出所有行。</p>
<p>with open('primenumbers.txt') as f:<br/> line = f.readline()<br/> while line:<br/> print(line)<br/> line = f.readline()<br/>We now want to just save each line as a separate integer into the list.</p>
<p>現在，我們只想將每一行作為單獨的整數保存到列表中。</p>
<p>primeslist = []<br/> with open('primenumbers.txt') as f:<br/> line = f.readline()<br/> while line:<br/> primeslist.append(int(line))<br/> line = f.readline()</p>
<p><br/>All we did was change the print into an append to the list, and make an empty list at the beginning. Note that before I append the line to my list, I turn it into an int with the int() statement.</p>
<p>我們要做的就是將打印內容更改為列表的追加，並在開頭添加一個空白列表。請注意，在將行添加到列表之前，請使用int（）語句將其轉換為int。</p>
<p>Now we have a choice. We can either do this twice (copy and paste the exact same code), or write a function to do this for us whenever we want.</p>
<p>現在我們有一個選擇。我們可以執行兩次（複製並粘貼完全相同的代碼），也可以編寫函數隨時為我們執行此操作。</p>
<p>Let’s make this into a function, for explanation’s sake. What we want to do here is make a function that I give the name of the file to, and it gives back to me a list of all the numbers in that file, assuming each line contains a separate integer. We need to add two lines to our code snippet from above, the function header and the return statement. The function header is just the name of the function with the list of variables to return, and the return statement is the line return list_of_ints at the end of the function.</p>
<p>為了說明起見，讓我們將其作為一個函數。我們要在這裡做的是創建一個函數，該函數將文件名提供給我，並且假定每行包含一個單獨的整數，它會向我返回該文件中所有數字的列表。我們需要在代碼段上方添加兩行，即函數標頭和return語句。函數頭只是函數的名稱，其中包含要返回的變量列表，而return語句是函數末尾的return list_of_ints行。</p>
<p>def filetolistofints(filename):<br/> list_of_ints = []<br/> with open(filename) as f:<br/> line = f.readline()<br/> while line:<br/> list_of_ints.append(int(line))<br/> line = f.readline()<br/> return list_of_ints<br/>Now I can use this function to read both of my files in two simple lines:</p>
<p>現在，我可以使用此功能以兩行代碼讀取兩個文件：</p>
<p>primeslist = filetolistofints('primenumbers.txt')<br/> happieslist = filetolistofints('happynumbers.txt')</p>
<p><br/>What I have now in my variables primeslist and happieslist are lists where each element was a number on a separate line in each of the files.</p>
<p>我現在在變量primeslist和happieslist中擁有的列表是其中每個元素在每個文件中的單獨一行上都是數字的列表。</p>
<p>My last step is to find the overlap between them. I can either use two for loops or a list comprehension. (If you need a refresher, Exercise 3 talks about for loops and Exercise 7 talks about list comprehensions.)</p>
<p>我的最後一步是找到它們之間的重疊。我可以使用兩個for循環或列表理解。 （如果需要復習，練習3討論for循環，練習7討論列表推導。）</p>
<p>As a list comprehension, you construct a new list that takes each element from primeslist and only adds it to our new list if it is inside happieslist.</p>
<p>作為列表理解，您構造了一個新列表，該列表從primeslist中獲取每個元素，並且僅將其添加到我們的新列表中（如果它位於happieslist中）。</p>
<p>overlaplist = [elem for elem in primeslist if elem in happieslist]<br/>This can also be done with a for loop, as below:</p>
<p>overlaplist = []<br/> for elem in primeslist:<br/> if elem in happieslist:<br/> overlaplist.append(elem)<br/>And when the loop is done, overlaplist will contain all the elements of the overlap.</p>
<p>並且當循環完成時，重疊列表將包含重疊的所有元素。</p>
<p>Now we can just print our result (using Python 3 syntax) and be done.</p>
<p>現在，我們可以打印結果（使用Python 3語法）並完成。</p>
<p>print(overlaplist)</p>
<p>For a full and concise solution once again, here it is:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def filetolistofints(filename):
	list_to_return = []
	with open(filename) as f:
		line = f.readline()
		while line:
			list_to_return.append(int(line))
			line = f.readline()
	return list_to_return

primeslist = filetolistofints('primenumbers.txt')
happieslist = filetolistofints('happynumbers.txt')

overlaplist = [elem for elem in primeslist if elem in happieslist]
print(overlaplist)</pre>
<pre><br/><br/></pre>
<h3>24.Draw A Game Board Solutions</h3>
<p>Sample solution<br/>Let’s break this task into pieces and use Python 3.</p>
<p>樣題解答<br/>讓我們將這項任務分解為幾部分，並使用Python 3。</p>
<p>First, the user needs to a numbers that represent the size of the game board (assuming the game board will be n by n). (Bonus exercise: extend the following code to make the game board not square.). The following snippet assumes that the person entered a number and doesn’t do any kind of error checking - for now, that’s OK.</p>
<p>首先，用戶需要一個代表遊戲板尺寸的數字（假設遊戲板為n×n）。 （獎勵練習：擴展以下代碼以使遊戲板不方形。）。以下代碼段假設此人輸入了一個數字，並且未進行任何類型的錯誤檢查-暫時可以。</p>
<p>board_size = int(input("What size of game board? "))</p>
<p>Then, we need to draw each row of the game board. Each row consists of horizontal pieces (---) and vertical pieces (|). Each of these shows up in a pattern, so we can rely on for loops to help with the rendering.</p>
<p>然後，我們需要繪製遊戲板的每一行。每行由水平塊（-）和垂直塊（|）組成。每一個都以一種模式顯示，因此我們可以依靠for循環來幫助進行渲染。</p>
<p>To print a single row, we want to do something like this:</p>
<p>要打印一行，我們想做這樣的事情：</p>
<p>print(" --- " * board_size)</p>
<p><br/>To print the vertical parts of the row, we want something like this, because we don’t care about trailing whitespace, and because we want one more vertical line than the size of the board:</p>
<p>要打印行的垂直部分，我們需要這樣的東西，因為我們不在乎尾隨空格，並且因為我們想要的垂直線比板子的尺寸還要多：</p>
<p>print("| " * (board_size + 1))</p>
<p>For a board of size board_size we want to print that many horizontal pieces and vertical pieces, plus an extra horizontal piece for the bottom. Let’s use functions for this entire operation, since we might want to change the style on the game boards for later use. All together, the program will look like this:</p>
<p>對於大小為board_size的板子，我們要打印許多水平件和垂直件，並在底部再增加一個水平件。讓我們在整個操作過程中使用各種功能，因為我們可能想更改遊戲板上的樣式以備後用。總之，該程序將如下所示：</p>
<p>def print_horiz_line():<br/> print(" --- " * board_size)</p>
<p>def print_vert_line():<br/> print("| " * (board_size + 1))</p>
<p>if __name__ == "__main__":<br/> board_size = int(input("What size of game board? "))</p>
<p>for index in range(board_size):<br/> print_horiz_line()<br/> print_vert_line()<br/> print horiz_line()</p>
<p><br/>This way, if we ever decide to change the design of the game board by making it bigger, it will be easy to do! All we need to do is change the print_horiz_line() and print_vert_line() functions, and we’re all set!</p>
<p>這樣，如果我們決定通過擴大遊戲板的設計來改變它的設計，那將很容易做到！我們需要做的就是更改print_horiz_line（）和print_vert_line（）函數，我們都準備好了！</p>
<p></p>
<p>A few user solutions not using functions<br/>This one is pretty simple, and it is specific to the 3x3 board above. There is no way to change the size. Additionally, writing out the a and b lists in the print statement are tedious and can be improved with a list comprehension or for loop.</p>
<p>一些不能作用功能的解決方案<br/>這很簡單，它特定於上面的3x3板。 無法更改大小。 此外，在print語句中寫出a和b列表很繁瑣，可以通過列表理解或for循環加以改進。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">a = '---'.join(' ')
b = ' '.join('||||')
print('\n'.join((a, b, a, b, a, b, a)))</pre>
<p>The author chose to use a while loop instead of a for loop to do the printing, which was an interesting choice. But it works!<br/>作者選擇使用while循環而不是for循環進行打印，這是一個有趣的選擇。 但這有效！</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def drawboard(kamal):
    kamal = int(kamal)
    i = 0
    ho = "--- "
    ve = "|   "
    ho = ho * kamal
    ve = ve * (kamal+1)
    while i &lt; kamal+1:
        print ho
        if not (i == kamal):
            print ve
        i += 1</pre>
<pre><br/><br/></pre><h3>25.Guessing Game Two Solutions</h3>
<p>Sample solution<br/>One user implemented an interesting strategy. Based on whether the number was lower or higher than the guess, randomly pick a number in that direction. This code is easy to read, even if it does not achieve the most efficient solution (and depends a little bit on randomness).</p>
<p>樣題解答<br/>一個用戶實施了一種有趣的策略。 根據數字是低於還是高於猜測，隨機選擇該方向上的數字。 即使沒有實現最有效的解決方案（並且在某種程度上取決於隨機性），該代碼也易於閱讀。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">'''
In a previous exercise, we've written a program that 'knows' a number and asks a user to guess it.
This time, we're going to do exactly the opposite.
You, the user, will have in your head a number between 0 and 100.
The program will guess a number, and you, the user, will say whether it is too high, too low, or your number.

At the end of this exchange, your program should print out how many guesses it took to get your number.

As the writer of this program, you will have to choose how your program will strategically guess.
A naive strategy can be to simply start the guessing at 1, and keep going (2, 3, 4, etc.) until you hit the number.
But that's not an optimal guessing strategy.
An alternate strategy might be to guess 50 (right in the middle of the range), and then increase / decrease by 1 as needed.
After you've written the program, try to find the optimal strategy! (We'll talk about what is the optimal one next week with the solution.)
'''

import random

# Awroken

MINIMUM = 0
MAXIMUM = 100
NUMBER = random.randint(MINIMUM, MAXIMUM)
TRY = 0
RUNNING = True
ANSWER = None

while RUNNING:
    print "Is it %s?" % str(NUMBER)
    ANSWER = raw_input()
    if "no" in ANSWER.lower() and "lower" in ANSWER.lower():
        NUMBER -= random.randint(1, 4)
    elif "no" in ANSWER.lower() and "higher" in ANSWER.lower():
        NUMBER += random.randint(1, 4)
    elif ANSWER.lower() == "no":
        print "Higher or lower?"
        ANSWER = raw_input()
        if ANSWER.lower() == "higher":
            NUMBER += random.randint(1, 4)
        elif ANSWER.lower() == "lower":
            NUMBER -= random.randint(1, 4)
    elif ANSWER.lower() == "yes":
        if TRY &lt; 2:
            print "Yes! It only took me %s try!" % str(TRY)
        elif TRY &lt; 2 and TRY &lt; 10:
            print "Pretty well for a robot, %s tries." % str(TRY)
        else:
            print "That's so bad, %s tries." % str(TRY)
        RUNNING = False
    TRY += 1
    
print "Thanks for the game!"</pre>
<pre><br/>Here is one user solution, implementing binary search:<br/>這是一個實現二進制搜索的用戶解決方案：</pre>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def guess():
    i = 0
    # i is the lowest number in range of possible guess
    j = 100
    # j is the highest number in range of possible guesses
    m = 50
    # m is the middle number in range of possible guesses
    counter = 1
    # counter is the number of guesses take.
    print "Please guess a number"
    condition = input("Is your guess " + str(m) + "? (0 means it's too low, 1 means it's your guess and 2 means it's too high) ")
    while condition != 1:
        counter += 1
        if condition == 0:
            i = m + 1
        elif condition == 2:
            j = m - 1
        m = (i + j) / 2
        condition = input("Is your guess " + str(m) + "? (0 means it's too low, 1 means it's your guess and 2 means it's too high) ")
    print "It took" , counter , "times to guess your number"
guess()</pre>
<pre>Explanation<br/>說明<br/>Theory<br/>The problem given in this exercise is called a search problem - the objective is to find something. <br/>It is solved by an algorithm called a search algorithm - an algorithm designed to find something. Not rocket science, I know, just terminology.<br/>理論<br/>在本練習中給出的問題稱為搜索問題-目的是找到一些東西。 它可以通過稱為搜索算法的算法來解決，該算法旨在查找某些內容。 我知道，不是火箭科學，只是術語。<br/><br/>The most optimal solution to this problem requires an algorithm called binary search, the most efficient search algorithm on sorted lists <br/>(for those who know about computational complexity, binary search is an O(log n) algorithm).<br/>解決此問題的最佳方法需要一種稱為二進制搜索的算法，這是排序列表上最有效的搜索算法（對於那些了解計算複雜性的人，二進制搜索是O（log n）算法）。<br/><br/>In a nutshell, binary search picks an element from a sorted list, then decides (based on some feedback of the target), whether to look earlier or later in the list. <br/>In the optimal form, the binary search algorithm will always look at the “center” of the list in question. <br/>The catch is that binary search relies on having the original list in question be sorted, or ordered either smallest to largest or largest to smallest.<br/>簡而言之，二進制搜索從排序列表中選擇一個元素，然後（基於目標的一些反饋）確定是在列表中查找更早還是稍後。 在最佳形式下，二進制搜索算法將始終查看所關注列表的“中心”。 <br/>問題是二進制搜索依賴於對原始列表進行排序，或者按最小到最大或最大到最小的順序排序。<br/><br/>Example + Code<br/>Let’s go through an example. Say you have this list: my_list = [-10, 1, 2, 6, 7, 12, 21], and we are trying to find the element 12 in the smallest number of steps. <br/>This means we want to search through the list until we find 8, and keep track of the index we look at. The binary search algorithm will start by looking at the item in the middle (in this case 6).<br/> We then task, is 6 less than or greater than our target (12)? It is less, so we need to look at the RIGHT HALF of the list. This means our new list we are looking at is [7, 12, 21]. <br/>We again look at the “center” element (12), and compare. <br/>It is 12, our target, so we are done!<br/>示例+代碼<br/>讓我們來看一個例子。 假設您有以下列表：my_list = [-10、1、2、6、7、12、21]，我們正在嘗試以最少的步驟數查找元素12。 <br/>這意味著我們要在列表中進行搜索，直到找到8，然後跟踪我們查看的索引。 二進制搜索算法將首先查看中間的項目（在本例中為6）。 <br/>然後，我們要完成任務，是目標6小於還是大於目標12？ 它的數量較少，因此我們需要查看列表的一半。 這意味著我們正在查看的新列表為[7，12，21]。 <br/>我們再次查看“中心”元素（12）並進行比較。 我們的目標是12，所以我們完成了！<br/><br/>In code, we can accomplish this with a while loop. <br/>We want to keep going until either we haven’t found the element, or our guess is equal to the element. <br/>The end conditions are len(my_list) == 0 or guess == target, so the while loop continues while those two conditions are NOT met.<br/>在代碼中，我們可以使用while循環來完成此操作。 <br/>我們要繼續下去，直到找不到元素或猜測等於該元素為止。 結束條件是len（my_list）== 0或guess == target，因此，當不滿足這兩個條件時，while循環將繼續。<br/><br/></pre>
<p>The function will look something like this (in Python 3), assuming the list is sorted from smallest to largest:</p>
<p>該函數看起來像這樣（在Python 3中），假設列表從最小到最大排序：</p>
<figure class="highlight">
<pre><code class="language-python" data-lang="python"><span class="n">my_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">guess</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">guess</span> <span class="o">==</span> <span class="n">target</span><span class="p">):</span>
  <span class="n">center_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="n">guess</span> <span class="o">=</span> <span class="n">my_list</span><span class="p">[</span><span class="n">center_index</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">guess</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="n">my_list</span><span class="p">[:</span><span class="n">center_index</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">guess</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
    <span class="n">my_list</span> <span class="o">=</span> <span class="n">my_list</span><span class="p">[</span><span class="n">center_index</span><span class="p">:]</span>

<span class="k">if</span> <span class="n">guess</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Found target! Guess = "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">guess</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Target not found. Last guess = "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">guess</span><span class="p">))</span></code></pre>
</figure>
<p>A few tricky things to note from the code:</p>
<p>從代碼中註意一些棘手的事情：</p>
<ul>
<li>We want to always be looking at the “center” element of the list, but if the list (or sublist) has an even number of elements, it needs to be converted into an integer, so it can be used as an index into a list. In my case, I just converted the result of the length of the list divided by 2 into an int, but there are other ways.</li>
<li>我們一直希望查看列表的“中心”元素，但是如果列表（或子列表）的元素數為偶數，則需要將其轉換為整數，因此可以將其用作索引。清單。就我而言，我只是將列表的長度除以2的結果轉換為一個int，但是還有其他方法。</li>
<li>The variable<span> </span><code class="highlighter-rouge">guess</code><span> </span>has to be given a value to start, but it doesn’t matter what that value is as long as it is not equal to<span> </span><code class="highlighter-rouge">target</code>. (<em>Why? because if<span> </span><code class="highlighter-rouge">guess</code><span> </span>were to start out equal to<span> </span><code class="highlighter-rouge">target</code>, the loop will never happen.</em>)</li>
<li>必須給變量猜測一個開始的值，但是只要該值不等於目標值，則無關緊要。 （為什麼？因為如果猜測始於目標，那麼循環將永遠不會發生。）</li>
<li>I have two conditions in my<span> </span><code class="highlighter-rouge">if</code><span> </span>statement: if the<span> </span><code class="highlighter-rouge">guess</code><span> </span>is less than the<span> </span><code class="highlighter-rouge">target</code>, or if<span> </span><code class="highlighter-rouge">guess</code><span> </span>is greater than the<span> </span><code class="highlighter-rouge">target</code>. In the case of the<span> </span><code class="highlighter-rouge">guess</code><span> </span>being less than the<span> </span><code class="highlighter-rouge">target</code>, I want to look at the half of the list on the RIGHT side of the<span> </span><code class="highlighter-rouge">guess</code>. The way I wrote it here, I am including the<span> </span><code class="highlighter-rouge">guess</code><span> </span>element in the sublist - this is not hugely important, since we will most likely remove that element later in the process anyway.</li>
<li>我的if語句有兩個條件：如果猜測小於目標，或者猜測大於目標。在猜測小於目標的情況下，我想查看猜測右邊的列表的一半。我在這裡編寫它的方式是，在子列表中包括了guess元素-這並不是很重要，因為無論如何我們很可能會在稍後的過程中刪除該元素。</li>
<li>You can put a<span> </span><code class="highlighter-rouge">print(my_list)</code><span> </span>and/or a<span> </span><code class="highlighter-rouge">print(guess)</code><span> </span>inside the<span> </span><code class="highlighter-rouge">while</code><span> </span>loop after the<span> </span><code class="highlighter-rouge">if</code><span> </span>statement to see the progress of the code.</li>
<li>您可以在if語句後的while循環中放置一個print（my_list）和/或一個print（guess），以查看代碼的進度。</li>
</ul>
<pre>Bonus code<br/>Lets way we wanted to add “monitoring” to our code. How many times did the while loop execute? Let’s just add a counter!<br/>加碼代碼<br/>讓我們想在代碼中添加“監視”。 while循環執行了多少次？ 讓我們添加一個計數器！<br/><br/>my_list = [-10, 1, 2, 6, 7, 12, 21]<br/>target = 12<br/>guess = 0<br/>numbet_of_loops = 0<br/>while not (len(my_list) == 1 or guess == target):<br/> center_index = int(len(my_list) / 2)<br/> guess = my_list[center_index]<br/> if guess &gt; target:<br/> my_list = my_list[:center_index]<br/> elif guess &lt; target:<br/> my_list = my_list[center_index:]<br/> number_of_loops += 1<br/><br/>if guess == target:<br/> print("Found target! Guess = " + str(guess))<br/>else:<br/> print("Target not found. Last guess = " + str(guess))<br/>print("while loop executed " + str(number_of_loops) + " times")<br/><br/>Try changing the value of target and see what happens!<br/>嘗試更改目標值，看看會發生什麼！<br/><br/>If you are feeling excited about this code and want to play more, try this bonus challenge:<br/> what happens if the list is sorted from largest to smallest? What has to change in the code?<br/>如果您對此代碼感到興奮並想玩更多遊戲，請嘗試以下獎金挑戰：如果列表從最大到最小排序會怎樣？ 代碼中需要更改什麼？<br/><br/>Answering the original question<br/>So, to answer the original question, there are two things that need to be modified from our code snippet above:<br/>回答原始問題<br/>因此，要回答原始問題，需要從上面的代碼片段中修改兩件事：<br/>The target needs to be set. <br/>The problem specifically specifies asking the user for feedback about whether the number is too big or too small, so that needs to be incorporated into the while loop.<br/>The list is now not a random collection of numbers - it is all the numbers in range(0, 100), so you can either construct the list that way,<br/>or compute the guesses on the fly without the list (like in the sample solution above).<br/>There are many ways to solve this problem! Try a few of them and see what you like.<br/>需要設定目標。 該問題特別指定要求用戶提供有關該數字太大還是太小的反饋，因此需要將其合併到while循環中。<br/>現在，列表不是數字的隨機集合-它是range（0，100）中的所有數字，因此您可以以這種方式構造列表，也可以在沒有列表的情況下即時計算猜測值（例如在示例解決方案中） 以上）。<br/>解決這個問題有很多方法！ 嘗試其中的一些，看看自己喜歡什麼。</pre>
